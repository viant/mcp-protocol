// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "errors"
import "fmt"
import "github.com/go-viper/mapstructure/v2"
import "reflect"
import "strings"

// Optional annotations for the client. The client can use annotations to inform
// how objects are used or displayed
type Annotations struct {
	// Describes who the intended audience of this object or data is.
	//
	// It can include multiple entries to indicate content useful for multiple
	// audiences (e.g., `["user", "assistant"]`).
	Audience []Role `json:"audience,omitempty" yaml:"audience,omitempty" mapstructure:"audience,omitempty"`

	// The moment the resource was last modified, as an ISO 8601 formatted string.
	//
	// Should be an ISO 8601 formatted string (e.g., "2025-01-12T15:00:58Z").
	//
	// Examples: last activity timestamp in an open file, timestamp when the resource
	// was attached, etc.
	LastModified *string `json:"lastModified,omitempty" yaml:"lastModified,omitempty" mapstructure:"lastModified,omitempty"`

	// Describes how important this data is for operating the server.
	//
	// A value of 1 means "most important," and indicates that the data is
	// effectively required, while 0 means "least important," and indicates that
	// the data is entirely optional.
	Priority *float64 `json:"priority,omitempty" yaml:"priority,omitempty" mapstructure:"priority,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Annotations) UnmarshalJSON(value []byte) error {
	type Plain Annotations
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Priority != nil && 1 < *plain.Priority {
		return fmt.Errorf("field %s: must be <= %v", "priority", 1)
	}
	if plain.Priority != nil && 0 > *plain.Priority {
		return fmt.Errorf("field %s: must be >= %v", "priority", 0)
	}
	*j = Annotations(plain)
	return nil
}

// Audio provided to or from an LLM.
type AudioContent struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Optional annotations for the client.
	Annotations *Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// The base64-encoded audio data.
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// The MIME type of the audio. Different providers may support different audio
	// types.
	MimeType string `json:"mimeType" yaml:"mimeType" mapstructure:"mimeType"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AudioContent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in AudioContent: required")
	}
	if _, ok := raw["mimeType"]; raw != nil && !ok {
		return fmt.Errorf("field mimeType in AudioContent: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AudioContent: required")
	}
	type Plain AudioContent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AudioContent(plain)
	return nil
}

// Base interface for metadata with name (identifier) and title (display name)
// properties.
type BaseMetadata struct {
	// Intended for programmatic or logical use, but used as a display name in past
	// specs or fallback (if title isn't present).
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Intended for UI and end-user contexts — optimized to be human-readable and
	// easily understood,
	// even by those unfamiliar with domain-specific terminology.
	//
	// If not provided, the name should be used for display (except for Tool,
	// where `annotations.title` should be given precedence over using `name`,
	// if present).
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BaseMetadata) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in BaseMetadata: required")
	}
	type Plain BaseMetadata
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = BaseMetadata(plain)
	return nil
}

type BlobResourceContents struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// A base64-encoded string representing the binary data of the item.
	Blob string `json:"blob" yaml:"blob" mapstructure:"blob"`

	// The MIME type of this resource, if known.
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// The URI of this resource.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlobResourceContents) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["blob"]; raw != nil && !ok {
		return fmt.Errorf("field blob in BlobResourceContents: required")
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in BlobResourceContents: required")
	}
	type Plain BlobResourceContents
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = BlobResourceContents(plain)
	return nil
}

type BooleanSchema struct {
	// Default corresponds to the JSON schema field "default".
	Default *bool `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Title corresponds to the JSON schema field "title".
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BooleanSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in BooleanSchema: required")
	}
	type Plain BooleanSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = BooleanSchema(plain)
	return nil
}

// Used by the client to invoke a tool provided by the server.
type CallToolRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params CallToolRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `tools/call` request.
type CallToolRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *CallToolRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Arguments to use for the tool call.
	Arguments map[string]interface{} `json:"arguments,omitempty" yaml:"arguments,omitempty" mapstructure:"arguments,omitempty"`

	// The name of the tool.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// If specified, the caller is requesting task-augmented execution for this
	// request.
	// The request will return a CreateTaskResult immediately, and the actual result
	// can be
	// retrieved later via tasks/result.
	//
	// Task augmentation is subject to capability negotiation - receivers MUST declare
	// support
	// for task augmentation of specific request types in their capabilities.
	Task *TaskMetadata `json:"task,omitempty" yaml:"task,omitempty" mapstructure:"task,omitempty"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type CallToolRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CallToolRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in CallToolRequestParams: required")
	}
	type Plain CallToolRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CallToolRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CallToolRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in CallToolRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in CallToolRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in CallToolRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in CallToolRequest: required")
	}
	type Plain CallToolRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CallToolRequest(plain)
	return nil
}

// The server's response to a tool call.
type CallToolResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// A list of content objects that represent the unstructured result of the tool
	// call.
	Content []CallToolResultContentElem `json:"content" yaml:"content" mapstructure:"content"`

	// Whether the tool call ended in an error.
	//
	// If not set, this is assumed to be false (the call was successful).
	//
	// Any errors that originate from the tool SHOULD be reported inside the result
	// object, with `isError` set to true, _not_ as an MCP protocol-level error
	// response. Otherwise, the LLM would not be able to see that an error occurred
	// and self-correct.
	//
	// However, any errors in _finding_ the tool, an error indicating that the
	// server does not support tool calls, or any other exceptional conditions,
	// should be reported as an MCP error response.
	IsError *bool `json:"isError,omitempty" yaml:"isError,omitempty" mapstructure:"isError,omitempty"`

	// An optional JSON object that represents the structured result of the tool call.
	StructuredContent map[string]interface{} `json:"structuredContent,omitempty" yaml:"structuredContent,omitempty" mapstructure:"structuredContent,omitempty"`
}

type CallToolResultContentElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CallToolResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in CallToolResult: required")
	}
	type Plain CallToolResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CallToolResult(plain)
	return nil
}

// A request to cancel a task.
type CancelTaskRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params CancelTaskRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

type CancelTaskRequestParams struct {
	// The task identifier to cancel.
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CancelTaskRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["taskId"]; raw != nil && !ok {
		return fmt.Errorf("field taskId in CancelTaskRequestParams: required")
	}
	type Plain CancelTaskRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CancelTaskRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CancelTaskRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in CancelTaskRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in CancelTaskRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in CancelTaskRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in CancelTaskRequest: required")
	}
	type Plain CancelTaskRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CancelTaskRequest(plain)
	return nil
}

// The response to a tasks/cancel request.
type CancelTaskResult interface{}

// This notification can be sent by either side to indicate that it is cancelling a
// previously-issued request.
//
// The request SHOULD still be in-flight, but due to communication latency, it is
// always possible that this notification MAY arrive after the request has already
// finished.
//
// This notification indicates that the result will be unused, so any associated
// processing SHOULD cease.
//
// A client MUST NOT attempt to cancel its `initialize` request.
//
// For task cancellation, use the `tasks/cancel` request instead of this
// notification.
type CancelledNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params CancelledNotificationParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `notifications/cancelled` notification.
type CancelledNotificationParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An optional string describing the reason for the cancellation. This MAY be
	// logged or presented to the user.
	Reason *string `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`

	// The ID of the request to cancel.
	//
	// This MUST correspond to the ID of a request previously issued in the same
	// direction.
	// This MUST be provided for cancelling non-task requests.
	// This MUST NOT be used for cancelling tasks (use the `tasks/cancel` request
	// instead).
	RequestId *RequestId `json:"requestId,omitempty" yaml:"requestId,omitempty" mapstructure:"requestId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CancelledNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in CancelledNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in CancelledNotification: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in CancelledNotification: required")
	}
	type Plain CancelledNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CancelledNotification(plain)
	return nil
}

// Capabilities a client may support. Known capabilities are defined here, in this
// schema, but this is not a closed set: any client can define its own, additional
// capabilities.
type ClientCapabilities struct {
	// Present if the client supports elicitation from the server.
	Elicitation *ClientCapabilitiesElicitation `json:"elicitation,omitempty" yaml:"elicitation,omitempty" mapstructure:"elicitation,omitempty"`

	// Experimental, non-standard capabilities that the client supports.
	Experimental map[string]map[string]interface{} `json:"experimental,omitempty" yaml:"experimental,omitempty" mapstructure:"experimental,omitempty"`

	// Present if the client supports listing roots.
	Roots *ClientCapabilitiesRoots `json:"roots,omitempty" yaml:"roots,omitempty" mapstructure:"roots,omitempty"`

	// Present if the client supports sampling from an LLM.
	Sampling *ClientCapabilitiesSampling `json:"sampling,omitempty" yaml:"sampling,omitempty" mapstructure:"sampling,omitempty"`

	// Present if the client supports task-augmented requests.
	Tasks *ClientCapabilitiesTasks `json:"tasks,omitempty" yaml:"tasks,omitempty" mapstructure:"tasks,omitempty"`
}

// Present if the client supports elicitation from the server.
type ClientCapabilitiesElicitation struct {
	// Form corresponds to the JSON schema field "form".
	Form map[string]interface{} `json:"form,omitempty" yaml:"form,omitempty" mapstructure:"form,omitempty"`

	// Url corresponds to the JSON schema field "url".
	Url map[string]interface{} `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

// Present if the client supports listing roots.
type ClientCapabilitiesRoots struct {
	// Whether the client supports notifications for changes to the roots list.
	ListChanged *bool `json:"listChanged,omitempty" yaml:"listChanged,omitempty" mapstructure:"listChanged,omitempty"`
}

// Present if the client supports sampling from an LLM.
type ClientCapabilitiesSampling struct {
	// Whether the client supports context inclusion via includeContext parameter.
	// If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
	Context map[string]interface{} `json:"context,omitempty" yaml:"context,omitempty" mapstructure:"context,omitempty"`

	// Whether the client supports tool use via tools and toolChoice parameters.
	Tools map[string]interface{} `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

// Present if the client supports task-augmented requests.
type ClientCapabilitiesTasks struct {
	// Whether this client supports tasks/cancel.
	Cancel map[string]interface{} `json:"cancel,omitempty" yaml:"cancel,omitempty" mapstructure:"cancel,omitempty"`

	// Whether this client supports tasks/list.
	List map[string]interface{} `json:"list,omitempty" yaml:"list,omitempty" mapstructure:"list,omitempty"`

	// Specifies which request types can be augmented with tasks.
	Requests *ClientCapabilitiesTasksRequests `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

// Specifies which request types can be augmented with tasks.
type ClientCapabilitiesTasksRequests struct {
	// Task support for elicitation-related requests.
	Elicitation *ClientCapabilitiesTasksRequestsElicitation `json:"elicitation,omitempty" yaml:"elicitation,omitempty" mapstructure:"elicitation,omitempty"`

	// Task support for sampling-related requests.
	Sampling *ClientCapabilitiesTasksRequestsSampling `json:"sampling,omitempty" yaml:"sampling,omitempty" mapstructure:"sampling,omitempty"`
}

// Task support for elicitation-related requests.
type ClientCapabilitiesTasksRequestsElicitation struct {
	// Whether the client supports task-augmented elicitation/create requests.
	Create map[string]interface{} `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`
}

// Task support for sampling-related requests.
type ClientCapabilitiesTasksRequestsSampling struct {
	// Whether the client supports task-augmented sampling/createMessage requests.
	CreateMessage map[string]interface{} `json:"createMessage,omitempty" yaml:"createMessage,omitempty" mapstructure:"createMessage,omitempty"`
}

type ClientNotification interface{}

type ClientRequest interface{}

type ClientResult interface{}

// A request from the client to the server, to ask for completion options.
type CompleteRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params CompleteRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `completion/complete` request.
type CompleteRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *CompleteRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The argument's information
	Argument CompleteRequestParamsArgument `json:"argument" yaml:"argument" mapstructure:"argument"`

	// Additional, optional context for completions
	Context *CompleteRequestParamsContext `json:"context,omitempty" yaml:"context,omitempty" mapstructure:"context,omitempty"`

	// Ref corresponds to the JSON schema field "ref".
	Ref CompleteRequestParamsRef `json:"ref" yaml:"ref" mapstructure:"ref"`
}

// The argument's information
type CompleteRequestParamsArgument struct {
	// The name of the argument
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The value of the argument to use for completion matching.
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CompleteRequestParamsArgument) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in CompleteRequestParamsArgument: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in CompleteRequestParamsArgument: required")
	}
	type Plain CompleteRequestParamsArgument
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CompleteRequestParamsArgument(plain)
	return nil
}

// Additional, optional context for completions
type CompleteRequestParamsContext struct {
	// Previously-resolved variables in a URI template or prompt.
	Arguments map[string]string `json:"arguments,omitempty" yaml:"arguments,omitempty" mapstructure:"arguments,omitempty"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type CompleteRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// Identifies a prompt.
type CompleteRequestParamsRef struct {
	// Intended for programmatic or logical use, but used as a display name in past
	// specs or fallback (if title isn't present).
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Intended for UI and end-user contexts — optimized to be human-readable and
	// easily understood,
	// even by those unfamiliar with domain-specific terminology.
	//
	// If not provided, the name should be used for display (except for Tool,
	// where `annotations.title` should be given precedence over using `name`,
	// if present).
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// The URI or URI template of the resource.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CompleteRequestParamsRef) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var completeRequestParamsRef_0 PromptReference
	var completeRequestParamsRef_1 ResourceTemplateReference
	var errs []error
	if err := completeRequestParamsRef_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := completeRequestParamsRef_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 2 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain CompleteRequestParamsRef
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CompleteRequestParamsRef(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CompleteRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["argument"]; raw != nil && !ok {
		return fmt.Errorf("field argument in CompleteRequestParams: required")
	}
	if _, ok := raw["ref"]; raw != nil && !ok {
		return fmt.Errorf("field ref in CompleteRequestParams: required")
	}
	type Plain CompleteRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CompleteRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CompleteRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in CompleteRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in CompleteRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in CompleteRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in CompleteRequest: required")
	}
	type Plain CompleteRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CompleteRequest(plain)
	return nil
}

// The server's response to a completion/complete request
type CompleteResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Completion corresponds to the JSON schema field "completion".
	Completion CompleteResultCompletion `json:"completion" yaml:"completion" mapstructure:"completion"`
}

type CompleteResultCompletion struct {
	// Indicates whether there are additional completion options beyond those provided
	// in the current response, even if the exact total is unknown.
	HasMore *bool `json:"hasMore,omitempty" yaml:"hasMore,omitempty" mapstructure:"hasMore,omitempty"`

	// The total number of completion options available. This can exceed the number of
	// values actually sent in the response.
	Total *int `json:"total,omitempty" yaml:"total,omitempty" mapstructure:"total,omitempty"`

	// An array of completion values. Must not exceed 100 items.
	Values []string `json:"values" yaml:"values" mapstructure:"values"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CompleteResultCompletion) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["values"]; raw != nil && !ok {
		return fmt.Errorf("field values in CompleteResultCompletion: required")
	}
	type Plain CompleteResultCompletion
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CompleteResultCompletion(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CompleteResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["completion"]; raw != nil && !ok {
		return fmt.Errorf("field completion in CompleteResult: required")
	}
	type Plain CompleteResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CompleteResult(plain)
	return nil
}

type ContentBlock interface{}

// A request from the server to sample an LLM via the client. The client has full
// discretion over which model to select. The client should also inform the user
// before beginning sampling, to allow them to inspect the request (human in the
// loop) and decide whether to approve it.
type CreateMessageRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params CreateMessageRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `sampling/createMessage` request.
type CreateMessageRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *CreateMessageRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// A request to include context from one or more MCP servers (including the
	// caller), to be attached to the prompt.
	// The client MAY ignore this request.
	//
	// Default is "none". Values "thisServer" and "allServers" are soft-deprecated.
	// Servers SHOULD only use these values if the client
	// declares ClientCapabilities.sampling.context. These values may be removed in
	// future spec releases.
	IncludeContext *CreateMessageRequestParamsIncludeContext `json:"includeContext,omitempty" yaml:"includeContext,omitempty" mapstructure:"includeContext,omitempty"`

	// The requested maximum number of tokens to sample (to prevent runaway
	// completions).
	//
	// The client MAY choose to sample fewer tokens than the requested maximum.
	MaxTokens int `json:"maxTokens" yaml:"maxTokens" mapstructure:"maxTokens"`

	// Messages corresponds to the JSON schema field "messages".
	Messages []SamplingMessage `json:"messages" yaml:"messages" mapstructure:"messages"`

	// Optional metadata to pass through to the LLM provider. The format of this
	// metadata is provider-specific.
	Metadata map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The server's preferences for which model to select. The client MAY ignore these
	// preferences.
	ModelPreferences *ModelPreferences `json:"modelPreferences,omitempty" yaml:"modelPreferences,omitempty" mapstructure:"modelPreferences,omitempty"`

	// StopSequences corresponds to the JSON schema field "stopSequences".
	StopSequences []string `json:"stopSequences,omitempty" yaml:"stopSequences,omitempty" mapstructure:"stopSequences,omitempty"`

	// An optional system prompt the server wants to use for sampling. The client MAY
	// modify or omit this prompt.
	SystemPrompt *string `json:"systemPrompt,omitempty" yaml:"systemPrompt,omitempty" mapstructure:"systemPrompt,omitempty"`

	// If specified, the caller is requesting task-augmented execution for this
	// request.
	// The request will return a CreateTaskResult immediately, and the actual result
	// can be
	// retrieved later via tasks/result.
	//
	// Task augmentation is subject to capability negotiation - receivers MUST declare
	// support
	// for task augmentation of specific request types in their capabilities.
	Task *TaskMetadata `json:"task,omitempty" yaml:"task,omitempty" mapstructure:"task,omitempty"`

	// Temperature corresponds to the JSON schema field "temperature".
	Temperature *float64 `json:"temperature,omitempty" yaml:"temperature,omitempty" mapstructure:"temperature,omitempty"`

	// Controls how the model uses tools.
	// The client MUST return an error if this field is provided but
	// ClientCapabilities.sampling.tools is not declared.
	// Default is `{ mode: "auto" }`.
	ToolChoice *ToolChoice `json:"toolChoice,omitempty" yaml:"toolChoice,omitempty" mapstructure:"toolChoice,omitempty"`

	// Tools that the model may use during generation.
	// The client MUST return an error if this field is provided but
	// ClientCapabilities.sampling.tools is not declared.
	Tools []Tool `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

type CreateMessageRequestParamsIncludeContext string

const CreateMessageRequestParamsIncludeContextAllServers CreateMessageRequestParamsIncludeContext = "allServers"
const CreateMessageRequestParamsIncludeContextNone CreateMessageRequestParamsIncludeContext = "none"
const CreateMessageRequestParamsIncludeContextThisServer CreateMessageRequestParamsIncludeContext = "thisServer"

var enumValues_CreateMessageRequestParamsIncludeContext = []interface{}{
	"allServers",
	"none",
	"thisServer",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CreateMessageRequestParamsIncludeContext) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CreateMessageRequestParamsIncludeContext {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CreateMessageRequestParamsIncludeContext, v)
	}
	*j = CreateMessageRequestParamsIncludeContext(v)
	return nil
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type CreateMessageRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CreateMessageRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["maxTokens"]; raw != nil && !ok {
		return fmt.Errorf("field maxTokens in CreateMessageRequestParams: required")
	}
	if _, ok := raw["messages"]; raw != nil && !ok {
		return fmt.Errorf("field messages in CreateMessageRequestParams: required")
	}
	type Plain CreateMessageRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CreateMessageRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CreateMessageRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in CreateMessageRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in CreateMessageRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in CreateMessageRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in CreateMessageRequest: required")
	}
	type Plain CreateMessageRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CreateMessageRequest(plain)
	return nil
}

// The client's response to a sampling/createMessage request from the server.
// The client should inform the user before returning the sampled message, to allow
// them
// to inspect the response (human in the loop) and decide whether to allow the
// server to see it.
type CreateMessageResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Content corresponds to the JSON schema field "content".
	Content CreateMessageResultContent `json:"content" yaml:"content" mapstructure:"content"`

	// The name of the model that generated the message.
	Model string `json:"model" yaml:"model" mapstructure:"model"`

	// Role corresponds to the JSON schema field "role".
	Role Role `json:"role" yaml:"role" mapstructure:"role"`

	// The reason why sampling stopped, if known.
	//
	// Standard values:
	// - "endTurn": Natural end of the assistant's turn
	// - "stopSequence": A stop sequence was encountered
	// - "maxTokens": Maximum token limit was reached
	// - "toolUse": The model wants to use one or more tools
	//
	// This field is an open string to allow for provider-specific stop reasons.
	StopReason *string `json:"stopReason,omitempty" yaml:"stopReason,omitempty" mapstructure:"stopReason,omitempty"`
}

// Text provided to or from an LLM.
type CreateMessageResultContent struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Optional annotations for the client.
	Annotations *Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// The unstructured result content of the tool use.
	//
	// This has the same format as CallToolResult.content and can include text,
	// images,
	// audio, resource links, and embedded resources.
	Content []ToolResultContentContentElem `json:"content" yaml:"content" mapstructure:"content"`

	// The base64-encoded image data.
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// A unique identifier for this tool use.
	//
	// This ID is used to match tool results to their corresponding tool uses.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The arguments to pass to the tool, conforming to the tool's input schema.
	Input map[string]interface{} `json:"input" yaml:"input" mapstructure:"input"`

	// Whether the tool use resulted in an error.
	//
	// If true, the content typically describes the error that occurred.
	// Default: false
	IsError *bool `json:"isError,omitempty" yaml:"isError,omitempty" mapstructure:"isError,omitempty"`

	// The MIME type of the image. Different providers may support different image
	// types.
	MimeType string `json:"mimeType" yaml:"mimeType" mapstructure:"mimeType"`

	// The name of the tool to call.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// An optional structured result object.
	//
	// If the tool defined an outputSchema, this SHOULD conform to that schema.
	StructuredContent map[string]interface{} `json:"structuredContent,omitempty" yaml:"structuredContent,omitempty" mapstructure:"structuredContent,omitempty"`

	// The text content of the message.
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// The ID of the tool use this result corresponds to.
	//
	// This MUST match the ID from a previous ToolUseContent.
	ToolUseId string `json:"toolUseId" yaml:"toolUseId" mapstructure:"toolUseId"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type CreateMessageResultContent_5Elem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CreateMessageResultContent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var createMessageResultContent_0 TextContent
	var createMessageResultContent_1 ImageContent
	var createMessageResultContent_2 AudioContent
	var createMessageResultContent_3 ToolUseContent
	var createMessageResultContent_4 ToolResultContent
	var errs []error
	if err := createMessageResultContent_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := createMessageResultContent_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := createMessageResultContent_2.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := createMessageResultContent_3.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := createMessageResultContent_4.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 6 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain CreateMessageResultContent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CreateMessageResultContent(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CreateMessageResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in CreateMessageResult: required")
	}
	if _, ok := raw["model"]; raw != nil && !ok {
		return fmt.Errorf("field model in CreateMessageResult: required")
	}
	if _, ok := raw["role"]; raw != nil && !ok {
		return fmt.Errorf("field role in CreateMessageResult: required")
	}
	type Plain CreateMessageResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CreateMessageResult(plain)
	return nil
}

// A response to a task-augmented request.
type CreateTaskResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Task corresponds to the JSON schema field "task".
	Task Task `json:"task" yaml:"task" mapstructure:"task"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CreateTaskResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["task"]; raw != nil && !ok {
		return fmt.Errorf("field task in CreateTaskResult: required")
	}
	type Plain CreateTaskResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CreateTaskResult(plain)
	return nil
}

// An opaque token used to represent a cursor for pagination.
type Cursor string

// A request from the server to elicit additional information from the user via the
// client.
type ElicitRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// ElicitRequestParams corresponds to the JSON schema field "params".
	ElicitRequestParams ElicitRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

type ElicitRequestElicitRequestParams interface{}

// Legacy params for elicitation requests (backward-compat).
type ElicitRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *URLElicitRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The ID of the elicitation, which must be unique within the context of the
	// server.
	// The client MUST treat this ID as an opaque value.
	ElicitationId string `json:"elicitationId" yaml:"elicitationId" mapstructure:"elicitationId"`

	// The message to present to the user.
	// For form mode: Describes what information is being requested.
	// For url mode: Explains why the interaction is needed.
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// The elicitation mode.
	Mode ElicitRequestParamsMode `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// A restricted subset of JSON Schema.
	// Only top-level properties are allowed, without nesting.
	RequestedSchema ElicitRequestParamsRequestedSchema `json:"requestedSchema,omitempty" yaml:"requestedSchema,omitempty" mapstructure:"requestedSchema,omitempty"`

	// The URL that the user should navigate to.
	Url string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

// Legacy mode enum for elicitation requests.
type ElicitRequestParamsMode string

const ElicitRequestParamsModeForm ElicitRequestParamsMode = "form"
const ElicitRequestParamsModeUrl ElicitRequestParamsMode = "url"

// Backward-compat alias for legacy requested schema.
type ElicitRequestParamsRequestedSchema = ElicitRequestFormParamsRequestedSchema

// Backward-compat alias for legacy meta name.
type URLElicitRequestParamsMeta = ElicitRequestURLParamsMeta

// The parameters for a request to elicit non-sensitive information from the user
// via a form in the client.
type ElicitRequestFormParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *ElicitRequestFormParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The message to present to the user describing what information is being
	// requested.
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// The elicitation mode.
	Mode *string `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// A restricted subset of JSON Schema.
	// Only top-level properties are allowed, without nesting.
	RequestedSchema ElicitRequestFormParamsRequestedSchema `json:"requestedSchema" yaml:"requestedSchema" mapstructure:"requestedSchema"`

	// If specified, the caller is requesting task-augmented execution for this
	// request.
	// The request will return a CreateTaskResult immediately, and the actual result
	// can be
	// retrieved later via tasks/result.
	//
	// Task augmentation is subject to capability negotiation - receivers MUST declare
	// support
	// for task augmentation of specific request types in their capabilities.
	Task *TaskMetadata `json:"task,omitempty" yaml:"task,omitempty" mapstructure:"task,omitempty"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type ElicitRequestFormParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// A restricted subset of JSON Schema.
// Only top-level properties are allowed, without nesting.
type ElicitRequestFormParamsRequestedSchema struct {
	// Schema corresponds to the JSON schema field "$schema".
	Schema *string `json:"$schema,omitempty" yaml:"$schema,omitempty" mapstructure:"$schema,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties map[string]interface{} `json:"properties" yaml:"properties" mapstructure:"properties"`

	// Required corresponds to the JSON schema field "required".
	Required []string `json:"required,omitempty" yaml:"required,omitempty" mapstructure:"required,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElicitRequestFormParamsRequestedSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["properties"]; raw != nil && !ok {
		return fmt.Errorf("field properties in ElicitRequestFormParamsRequestedSchema: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ElicitRequestFormParamsRequestedSchema: required")
	}
	type Plain ElicitRequestFormParamsRequestedSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ElicitRequestFormParamsRequestedSchema(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElicitRequestFormParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in ElicitRequestFormParams: required")
	}
	if _, ok := raw["requestedSchema"]; raw != nil && !ok {
		return fmt.Errorf("field requestedSchema in ElicitRequestFormParams: required")
	}
	type Plain ElicitRequestFormParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ElicitRequestFormParams(plain)
	return nil
}

// The parameters for a request to elicit information from the user via a URL in
// the client.
type ElicitRequestURLParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *ElicitRequestURLParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The ID of the elicitation, which must be unique within the context of the
	// server.
	// The client MUST treat this ID as an opaque value.
	ElicitationId string `json:"elicitationId" yaml:"elicitationId" mapstructure:"elicitationId"`

	// The message to present to the user explaining why the interaction is needed.
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// The elicitation mode.
	Mode string `json:"mode" yaml:"mode" mapstructure:"mode"`

	// If specified, the caller is requesting task-augmented execution for this
	// request.
	// The request will return a CreateTaskResult immediately, and the actual result
	// can be
	// retrieved later via tasks/result.
	//
	// Task augmentation is subject to capability negotiation - receivers MUST declare
	// support
	// for task augmentation of specific request types in their capabilities.
	Task *TaskMetadata `json:"task,omitempty" yaml:"task,omitempty" mapstructure:"task,omitempty"`

	// The URL that the user should navigate to.
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type ElicitRequestURLParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElicitRequestURLParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["elicitationId"]; raw != nil && !ok {
		return fmt.Errorf("field elicitationId in ElicitRequestURLParams: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in ElicitRequestURLParams: required")
	}
	if _, ok := raw["mode"]; raw != nil && !ok {
		return fmt.Errorf("field mode in ElicitRequestURLParams: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in ElicitRequestURLParams: required")
	}
	type Plain ElicitRequestURLParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ElicitRequestURLParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElicitRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ElicitRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ElicitRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ElicitRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in ElicitRequest: required")
	}
	type Plain ElicitRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ElicitRequest(plain)
	return nil
}

// The client's response to an elicitation request.
type ElicitResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The user action in response to the elicitation.
	// - "accept": User submitted the form/confirmed the action
	// - "decline": User explicitly decline the action
	// - "cancel": User dismissed without making an explicit choice
	Action ElicitResultAction `json:"action" yaml:"action" mapstructure:"action"`

	// The submitted form data, only present when action is "accept" and mode was
	// "form".
	// Contains values matching the requested schema.
	// Omitted for out-of-band mode responses.
	Content map[string]interface{} `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`
}

type ElicitResultAction string

const ElicitResultActionAccept ElicitResultAction = "accept"
const ElicitResultActionCancel ElicitResultAction = "cancel"
const ElicitResultActionDecline ElicitResultAction = "decline"

var enumValues_ElicitResultAction = []interface{}{
	"accept",
	"cancel",
	"decline",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElicitResultAction) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ElicitResultAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ElicitResultAction, v)
	}
	*j = ElicitResultAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElicitResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["action"]; raw != nil && !ok {
		return fmt.Errorf("field action in ElicitResult: required")
	}
	type Plain ElicitResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ElicitResult(plain)
	return nil
}

// An optional notification from the server to the client, informing it of a
// completion of a out-of-band elicitation request.
type ElicitationCompleteNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params ElicitationCompleteNotificationParams `json:"params" yaml:"params" mapstructure:"params"`
}

type ElicitationCompleteNotificationParams struct {
	// The ID of the elicitation that completed.
	ElicitationId string `json:"elicitationId" yaml:"elicitationId" mapstructure:"elicitationId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElicitationCompleteNotificationParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["elicitationId"]; raw != nil && !ok {
		return fmt.Errorf("field elicitationId in ElicitationCompleteNotificationParams: required")
	}
	type Plain ElicitationCompleteNotificationParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ElicitationCompleteNotificationParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ElicitationCompleteNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ElicitationCompleteNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ElicitationCompleteNotification: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in ElicitationCompleteNotification: required")
	}
	type Plain ElicitationCompleteNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ElicitationCompleteNotification(plain)
	return nil
}

// The contents of a resource, embedded into a prompt or tool call result.
//
// It is up to the client how best to render embedded resources for the benefit
// of the LLM and/or the user.
type EmbeddedResource struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Optional annotations for the client.
	Annotations *Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Resource corresponds to the JSON schema field "resource".
	Resource EmbeddedResourceResource `json:"resource" yaml:"resource" mapstructure:"resource"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type EmbeddedResourceResource struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// A base64-encoded string representing the binary data of the item.
	Blob string `json:"blob" yaml:"blob" mapstructure:"blob"`

	// The MIME type of this resource, if known.
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// The text of the item. This must only be set if the item can actually be
	// represented as text (not binary data).
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// The URI of this resource.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedResourceResource) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var embeddedResourceResource_0 TextResourceContents
	var embeddedResourceResource_1 BlobResourceContents
	var errs []error
	if err := embeddedResourceResource_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := embeddedResourceResource_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 2 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain EmbeddedResourceResource
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EmbeddedResourceResource(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmbeddedResource) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resource"]; raw != nil && !ok {
		return fmt.Errorf("field resource in EmbeddedResource: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in EmbeddedResource: required")
	}
	type Plain EmbeddedResource
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EmbeddedResource(plain)
	return nil
}

type EnumSchema interface{}

type Error struct {
	// The error type that occurred.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// Additional information about the error. The value of this member is defined by
	// the sender (e.g. detailed error information, nested errors etc.).
	Data interface{} `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// A short description of the error. The message SHOULD be limited to a concise
	// single sentence.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Error) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in Error: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in Error: required")
	}
	type Plain Error
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Error(plain)
	return nil
}

// Used by the client to get a prompt provided by the server.
type GetPromptRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params GetPromptRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `prompts/get` request.
type GetPromptRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *GetPromptRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Arguments to use for templating the prompt.
	Arguments map[string]string `json:"arguments,omitempty" yaml:"arguments,omitempty" mapstructure:"arguments,omitempty"`

	// The name of the prompt or prompt template.
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type GetPromptRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPromptRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in GetPromptRequestParams: required")
	}
	type Plain GetPromptRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetPromptRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPromptRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in GetPromptRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in GetPromptRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in GetPromptRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in GetPromptRequest: required")
	}
	type Plain GetPromptRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetPromptRequest(plain)
	return nil
}

// The server's response to a prompts/get request from the client.
type GetPromptResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An optional description for the prompt.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Messages corresponds to the JSON schema field "messages".
	Messages []PromptMessage `json:"messages" yaml:"messages" mapstructure:"messages"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPromptResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["messages"]; raw != nil && !ok {
		return fmt.Errorf("field messages in GetPromptResult: required")
	}
	type Plain GetPromptResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetPromptResult(plain)
	return nil
}

// A request to retrieve the result of a completed task.
type GetTaskPayloadRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params GetTaskPayloadRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

type GetTaskPayloadRequestParams struct {
	// The task identifier to retrieve results for.
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTaskPayloadRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["taskId"]; raw != nil && !ok {
		return fmt.Errorf("field taskId in GetTaskPayloadRequestParams: required")
	}
	type Plain GetTaskPayloadRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetTaskPayloadRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTaskPayloadRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in GetTaskPayloadRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in GetTaskPayloadRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in GetTaskPayloadRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in GetTaskPayloadRequest: required")
	}
	type Plain GetTaskPayloadRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetTaskPayloadRequest(plain)
	return nil
}

// The response to a tasks/result request.
// The structure matches the result type of the original request.
// For example, a tools/call task would return the CallToolResult structure.
type GetTaskPayloadResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// A request to retrieve the state of a task.
type GetTaskRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params GetTaskRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

type GetTaskRequestParams struct {
	// The task identifier to query.
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTaskRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["taskId"]; raw != nil && !ok {
		return fmt.Errorf("field taskId in GetTaskRequestParams: required")
	}
	type Plain GetTaskRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetTaskRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTaskRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in GetTaskRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in GetTaskRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in GetTaskRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in GetTaskRequest: required")
	}
	type Plain GetTaskRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = GetTaskRequest(plain)
	return nil
}

// The response to a tasks/get request.
type GetTaskResult interface{}

// An optionally-sized icon that can be displayed in a user interface.
type Icon struct {
	// Optional MIME type override if the source MIME type is missing or generic.
	// For example: `"image/png"`, `"image/jpeg"`, or `"image/svg+xml"`.
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// Optional array of strings that specify sizes at which the icon can be used.
	// Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for
	// scalable formats like SVG.
	//
	// If not provided, the client should assume that the icon can be used at any
	// size.
	Sizes []string `json:"sizes,omitempty" yaml:"sizes,omitempty" mapstructure:"sizes,omitempty"`

	// A standard URI pointing to an icon resource. May be an HTTP/HTTPS URL or a
	// `data:` URI with Base64-encoded image data.
	//
	// Consumers SHOULD takes steps to ensure URLs serving icons are from the
	// same domain as the client/server or a trusted domain.
	//
	// Consumers SHOULD take appropriate precautions when consuming SVGs as they can
	// contain
	// executable JavaScript.
	Src string `json:"src" yaml:"src" mapstructure:"src"`

	// Optional specifier for the theme this icon is designed for. `light` indicates
	// the icon is designed to be used with a light background, and `dark` indicates
	// the icon is designed to be used with a dark background.
	//
	// If not provided, the client should assume the icon can be used with any theme.
	Theme *IconTheme `json:"theme,omitempty" yaml:"theme,omitempty" mapstructure:"theme,omitempty"`
}

type IconTheme string

const IconThemeDark IconTheme = "dark"
const IconThemeLight IconTheme = "light"

var enumValues_IconTheme = []interface{}{
	"dark",
	"light",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IconTheme) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IconTheme {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IconTheme, v)
	}
	*j = IconTheme(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Icon) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["src"]; raw != nil && !ok {
		return fmt.Errorf("field src in Icon: required")
	}
	type Plain Icon
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Icon(plain)
	return nil
}

// Base interface to add `icons` property.
type Icons struct {
	// Optional set of sized icons that the client can display in a user interface.
	//
	// Clients that support rendering icons MUST support at least the following MIME
	// types:
	// - `image/png` - PNG images (safe, universal compatibility)
	// - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
	//
	// Clients that support rendering icons SHOULD also support:
	// - `image/svg+xml` - SVG images (scalable but requires security precautions)
	// - `image/webp` - WebP images (modern, efficient format)
	Icons []Icon `json:"icons,omitempty" yaml:"icons,omitempty" mapstructure:"icons,omitempty"`
}

// An image provided to or from an LLM.
type ImageContent struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Optional annotations for the client.
	Annotations *Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// The base64-encoded image data.
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// The MIME type of the image. Different providers may support different image
	// types.
	MimeType string `json:"mimeType" yaml:"mimeType" mapstructure:"mimeType"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImageContent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in ImageContent: required")
	}
	if _, ok := raw["mimeType"]; raw != nil && !ok {
		return fmt.Errorf("field mimeType in ImageContent: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ImageContent: required")
	}
	type Plain ImageContent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ImageContent(plain)
	return nil
}

// Describes the MCP implementation.
type Implementation struct {
	// An optional human-readable description of what this implementation does.
	//
	// This can be used by clients or servers to provide context about their purpose
	// and capabilities. For example, a server might describe the types of resources
	// or tools it provides, while a client might describe its intended use case.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Optional set of sized icons that the client can display in a user interface.
	//
	// Clients that support rendering icons MUST support at least the following MIME
	// types:
	// - `image/png` - PNG images (safe, universal compatibility)
	// - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
	//
	// Clients that support rendering icons SHOULD also support:
	// - `image/svg+xml` - SVG images (scalable but requires security precautions)
	// - `image/webp` - WebP images (modern, efficient format)
	Icons []Icon `json:"icons,omitempty" yaml:"icons,omitempty" mapstructure:"icons,omitempty"`

	// Intended for programmatic or logical use, but used as a display name in past
	// specs or fallback (if title isn't present).
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Intended for UI and end-user contexts — optimized to be human-readable and
	// easily understood,
	// even by those unfamiliar with domain-specific terminology.
	//
	// If not provided, the name should be used for display (except for Tool,
	// where `annotations.title` should be given precedence over using `name`,
	// if present).
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`

	// An optional URL of the website for this implementation.
	WebsiteUrl *string `json:"websiteUrl,omitempty" yaml:"websiteUrl,omitempty" mapstructure:"websiteUrl,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Implementation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Implementation: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in Implementation: required")
	}
	type Plain Implementation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Implementation(plain)
	return nil
}

func NewImplementation(name string, version string) *Implementation {
	return &Implementation{Name: name, Version: version}
}

// This request is sent from the client to the server when it first connects,
// asking it to begin initialization.
type InitializeRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params InitializeRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for an `initialize` request.
type InitializeRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *InitializeRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities ClientCapabilities `json:"capabilities" yaml:"capabilities" mapstructure:"capabilities"`

	// ClientInfo corresponds to the JSON schema field "clientInfo".
	ClientInfo Implementation `json:"clientInfo" yaml:"clientInfo" mapstructure:"clientInfo"`

	// The latest version of the Model Context Protocol that the client supports. The
	// client MAY decide to support older versions as well.
	ProtocolVersion string `json:"protocolVersion" yaml:"protocolVersion" mapstructure:"protocolVersion"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type InitializeRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InitializeRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["capabilities"]; raw != nil && !ok {
		return fmt.Errorf("field capabilities in InitializeRequestParams: required")
	}
	if _, ok := raw["clientInfo"]; raw != nil && !ok {
		return fmt.Errorf("field clientInfo in InitializeRequestParams: required")
	}
	if _, ok := raw["protocolVersion"]; raw != nil && !ok {
		return fmt.Errorf("field protocolVersion in InitializeRequestParams: required")
	}
	type Plain InitializeRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InitializeRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InitializeRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in InitializeRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in InitializeRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in InitializeRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in InitializeRequest: required")
	}
	type Plain InitializeRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InitializeRequest(plain)
	return nil
}

// After receiving an initialize request from the client, the server sends this
// response.
type InitializeResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities ServerCapabilities `json:"capabilities" yaml:"capabilities" mapstructure:"capabilities"`

	// Instructions describing how to use the server and its features.
	//
	// This can be used by clients to improve the LLM's understanding of available
	// tools, resources, etc. It can be thought of like a "hint" to the model. For
	// example, this information MAY be added to the system prompt.
	Instructions *string `json:"instructions,omitempty" yaml:"instructions,omitempty" mapstructure:"instructions,omitempty"`

	// The version of the Model Context Protocol that the server wants to use. This
	// may not match the version that the client requested. If the client cannot
	// support this version, it MUST disconnect.
	ProtocolVersion string `json:"protocolVersion" yaml:"protocolVersion" mapstructure:"protocolVersion"`

	// ServerInfo corresponds to the JSON schema field "serverInfo".
	ServerInfo Implementation `json:"serverInfo" yaml:"serverInfo" mapstructure:"serverInfo"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InitializeResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["capabilities"]; raw != nil && !ok {
		return fmt.Errorf("field capabilities in InitializeResult: required")
	}
	if _, ok := raw["protocolVersion"]; raw != nil && !ok {
		return fmt.Errorf("field protocolVersion in InitializeResult: required")
	}
	if _, ok := raw["serverInfo"]; raw != nil && !ok {
		return fmt.Errorf("field serverInfo in InitializeResult: required")
	}
	type Plain InitializeResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InitializeResult(plain)
	return nil
}

// This notification is sent from the client to the server after initialization has
// finished.
type InitializedNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *NotificationParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InitializedNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in InitializedNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in InitializedNotification: required")
	}
	type Plain InitializedNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = InitializedNotification(plain)
	return nil
}

// A response to a request that indicates an error occurred.
type JSONRPCErrorResponse struct {
	// Error corresponds to the JSON schema field "error".
	Error Error `json:"error" yaml:"error" mapstructure:"error"`

	// Id corresponds to the JSON schema field "id".
	Id *RequestId `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONRPCErrorResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["error"]; raw != nil && !ok {
		return fmt.Errorf("field error in JSONRPCErrorResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in JSONRPCErrorResponse: required")
	}
	type Plain JSONRPCErrorResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = JSONRPCErrorResponse(plain)
	return nil
}

// Refers to any valid JSON-RPC object that can be decoded off the wire, or encoded
// to be sent.
type JSONRPCMessage interface{}

// A notification which does not expect a response.
type JSONRPCNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// NotificationParams corresponds to the JSON schema field "params".
	NotificationParams map[string]interface{} `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONRPCNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in JSONRPCNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in JSONRPCNotification: required")
	}
	type Plain JSONRPCNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = JSONRPCNotification(plain)
	return nil
}

// A request that expects a response.
type JSONRPCRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params map[string]interface{} `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONRPCRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in JSONRPCRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in JSONRPCRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in JSONRPCRequest: required")
	}
	type Plain JSONRPCRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = JSONRPCRequest(plain)
	return nil
}

// A response to a request, containing either the result or error.
type JSONRPCResponse interface{}

// A successful (non-error) response to a request.
type JSONRPCResultResponse struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Result corresponds to the JSON schema field "result".
	Result Result `json:"result" yaml:"result" mapstructure:"result"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JSONRPCResultResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in JSONRPCResultResponse: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in JSONRPCResultResponse: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in JSONRPCResultResponse: required")
	}
	type Plain JSONRPCResultResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = JSONRPCResultResponse(plain)
	return nil
}

// Use TitledSingleSelectEnumSchema instead.
// This interface will be removed in a future version.
type LegacyTitledEnumSchema struct {
	// Default corresponds to the JSON schema field "default".
	Default *string `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Enum corresponds to the JSON schema field "enum".
	Enum []string `json:"enum" yaml:"enum" mapstructure:"enum"`

	// (Legacy) Display names for enum values.
	// Non-standard according to JSON schema 2020-12.
	EnumNames []string `json:"enumNames,omitempty" yaml:"enumNames,omitempty" mapstructure:"enumNames,omitempty"`

	// Title corresponds to the JSON schema field "title".
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LegacyTitledEnumSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["enum"]; raw != nil && !ok {
		return fmt.Errorf("field enum in LegacyTitledEnumSchema: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in LegacyTitledEnumSchema: required")
	}
	type Plain LegacyTitledEnumSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = LegacyTitledEnumSchema(plain)
	return nil
}

// Sent from the client to request a list of prompts and prompt templates the
// server has.
type ListPromptsRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// PaginatedRequestParams corresponds to the JSON schema field "params".
	PaginatedRequestParams *PaginatedRequestParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListPromptsRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ListPromptsRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ListPromptsRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ListPromptsRequest: required")
	}
	type Plain ListPromptsRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListPromptsRequest(plain)
	return nil
}

// The server's response to a prompts/list request from the client.
type ListPromptsResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An opaque token representing the pagination position after the last returned
	// result.
	// If present, there may be more results available.
	NextCursor *string `json:"nextCursor,omitempty" yaml:"nextCursor,omitempty" mapstructure:"nextCursor,omitempty"`

	// Prompts corresponds to the JSON schema field "prompts".
	Prompts []Prompt `json:"prompts" yaml:"prompts" mapstructure:"prompts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListPromptsResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["prompts"]; raw != nil && !ok {
		return fmt.Errorf("field prompts in ListPromptsResult: required")
	}
	type Plain ListPromptsResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListPromptsResult(plain)
	return nil
}

// Sent from the client to request a list of resource templates the server has.
type ListResourceTemplatesRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// PaginatedRequestParams corresponds to the JSON schema field "params".
	PaginatedRequestParams *PaginatedRequestParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListResourceTemplatesRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ListResourceTemplatesRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ListResourceTemplatesRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ListResourceTemplatesRequest: required")
	}
	type Plain ListResourceTemplatesRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListResourceTemplatesRequest(plain)
	return nil
}

// The server's response to a resources/templates/list request from the client.
type ListResourceTemplatesResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An opaque token representing the pagination position after the last returned
	// result.
	// If present, there may be more results available.
	NextCursor *string `json:"nextCursor,omitempty" yaml:"nextCursor,omitempty" mapstructure:"nextCursor,omitempty"`

	// ResourceTemplates corresponds to the JSON schema field "resourceTemplates".
	ResourceTemplates []ResourceTemplate `json:"resourceTemplates" yaml:"resourceTemplates" mapstructure:"resourceTemplates"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListResourceTemplatesResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resourceTemplates"]; raw != nil && !ok {
		return fmt.Errorf("field resourceTemplates in ListResourceTemplatesResult: required")
	}
	type Plain ListResourceTemplatesResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListResourceTemplatesResult(plain)
	return nil
}

// Sent from the client to request a list of resources the server has.
type ListResourcesRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *PaginatedRequestParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListResourcesRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ListResourcesRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ListResourcesRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ListResourcesRequest: required")
	}
	type Plain ListResourcesRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListResourcesRequest(plain)
	return nil
}

// The server's response to a resources/list request from the client.
type ListResourcesResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An opaque token representing the pagination position after the last returned
	// result.
	// If present, there may be more results available.
	NextCursor *string `json:"nextCursor,omitempty" yaml:"nextCursor,omitempty" mapstructure:"nextCursor,omitempty"`

	// Resources corresponds to the JSON schema field "resources".
	Resources []Resource `json:"resources" yaml:"resources" mapstructure:"resources"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListResourcesResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["resources"]; raw != nil && !ok {
		return fmt.Errorf("field resources in ListResourcesResult: required")
	}
	type Plain ListResourcesResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListResourcesResult(plain)
	return nil
}

// Sent from the server to request a list of root URIs from the client. Roots allow
// servers to ask for specific directories or files to operate on. A common example
// for roots is providing a set of repositories or directories a server should
// operate
// on.
//
// This request is typically used when the server needs to understand the file
// system
// structure or access specific locations that the client has permission to read
// from.
type ListRootsRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *RequestParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListRootsRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ListRootsRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ListRootsRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ListRootsRequest: required")
	}
	type Plain ListRootsRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListRootsRequest(plain)
	return nil
}

// The client's response to a roots/list request from the server.
// This result contains an array of Root objects, each representing a root
// directory
// or file that the server can operate on.
type ListRootsResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Roots corresponds to the JSON schema field "roots".
	Roots []Root `json:"roots" yaml:"roots" mapstructure:"roots"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListRootsResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["roots"]; raw != nil && !ok {
		return fmt.Errorf("field roots in ListRootsResult: required")
	}
	type Plain ListRootsResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListRootsResult(plain)
	return nil
}

// A request to retrieve a list of tasks.
type ListTasksRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *PaginatedRequestParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListTasksRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ListTasksRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ListTasksRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ListTasksRequest: required")
	}
	type Plain ListTasksRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListTasksRequest(plain)
	return nil
}

// The response to a tasks/list request.
type ListTasksResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An opaque token representing the pagination position after the last returned
	// result.
	// If present, there may be more results available.
	NextCursor *string `json:"nextCursor,omitempty" yaml:"nextCursor,omitempty" mapstructure:"nextCursor,omitempty"`

	// Tasks corresponds to the JSON schema field "tasks".
	Tasks []Task `json:"tasks" yaml:"tasks" mapstructure:"tasks"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListTasksResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["tasks"]; raw != nil && !ok {
		return fmt.Errorf("field tasks in ListTasksResult: required")
	}
	type Plain ListTasksResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListTasksResult(plain)
	return nil
}

// Sent from the client to request a list of tools the server has.
type ListToolsRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *PaginatedRequestParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListToolsRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ListToolsRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ListToolsRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ListToolsRequest: required")
	}
	type Plain ListToolsRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListToolsRequest(plain)
	return nil
}

// The server's response to a tools/list request from the client.
type ListToolsResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An opaque token representing the pagination position after the last returned
	// result.
	// If present, there may be more results available.
	NextCursor *string `json:"nextCursor,omitempty" yaml:"nextCursor,omitempty" mapstructure:"nextCursor,omitempty"`

	// Tools corresponds to the JSON schema field "tools".
	Tools []Tool `json:"tools" yaml:"tools" mapstructure:"tools"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ListToolsResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["tools"]; raw != nil && !ok {
		return fmt.Errorf("field tools in ListToolsResult: required")
	}
	type Plain ListToolsResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ListToolsResult(plain)
	return nil
}

type LoggingLevel string

const LoggingLevelAlert LoggingLevel = "alert"
const LoggingLevelCritical LoggingLevel = "critical"
const LoggingLevelDebug LoggingLevel = "debug"
const LoggingLevelEmergency LoggingLevel = "emergency"
const LoggingLevelError LoggingLevel = "error"
const LoggingLevelInfo LoggingLevel = "info"
const LoggingLevelNotice LoggingLevel = "notice"
const LoggingLevelWarning LoggingLevel = "warning"

var enumValues_LoggingLevel = []interface{}{
	"alert",
	"critical",
	"debug",
	"emergency",
	"error",
	"info",
	"notice",
	"warning",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoggingLevel) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LoggingLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LoggingLevel, v)
	}
	*j = LoggingLevel(v)
	return nil
}

// JSONRPCNotification of a log message passed from server to client. If no
// logging/setLevel request has been sent from the client, the server MAY decide
// which messages to send automatically.
type LoggingMessageNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params LoggingMessageNotificationParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `notifications/message` notification.
type LoggingMessageNotificationParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The data to be logged, such as a string message or an object. Any JSON
	// serializable type is allowed here.
	Data interface{} `json:"data" yaml:"data" mapstructure:"data"`

	// The severity of this log message.
	Level LoggingLevel `json:"level" yaml:"level" mapstructure:"level"`

	// An optional name of the logger issuing this message.
	Logger *string `json:"logger,omitempty" yaml:"logger,omitempty" mapstructure:"logger,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoggingMessageNotificationParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in LoggingMessageNotificationParams: required")
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in LoggingMessageNotificationParams: required")
	}
	type Plain LoggingMessageNotificationParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = LoggingMessageNotificationParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoggingMessageNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in LoggingMessageNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in LoggingMessageNotification: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in LoggingMessageNotification: required")
	}
	type Plain LoggingMessageNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = LoggingMessageNotification(plain)
	return nil
}

// Hints to use for model selection.
//
// Keys not declared here are currently left unspecified by the spec and are up
// to the client to interpret.
type ModelHint struct {
	// A hint for a model name.
	//
	// The client SHOULD treat this as a substring of a model name; for example:
	//  - `claude-3-5-sonnet` should match `claude-3-5-sonnet-20241022`
	//  - `sonnet` should match `claude-3-5-sonnet-20241022`,
	// `claude-3-sonnet-20240229`, etc.
	//  - `claude` should match any Claude model
	//
	// The client MAY also map the string to a different provider's model name or a
	// different model family, as long as it fills a similar niche; for example:
	//  - `gemini-1.5-flash` could match `claude-3-haiku-20240307`
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// The server's preferences for model selection, requested of the client during
// sampling.
//
// Because LLMs can vary along multiple dimensions, choosing the "best" model is
// rarely straightforward.  Different models excel in different areas—some are
// faster but less capable, others are more capable but more expensive, and so
// on. This interface allows servers to express their priorities across multiple
// dimensions to help clients make an appropriate selection for their use case.
//
// These preferences are always advisory. The client MAY ignore them. It is also
// up to the client to decide how to interpret these preferences and how to
// balance them against other considerations.
type ModelPreferences struct {
	// How much to prioritize cost when selecting a model. A value of 0 means cost
	// is not important, while a value of 1 means cost is the most important
	// factor.
	CostPriority *float64 `json:"costPriority,omitempty" yaml:"costPriority,omitempty" mapstructure:"costPriority,omitempty"`

	// Optional hints to use for model selection.
	//
	// If multiple hints are specified, the client MUST evaluate them in order
	// (such that the first match is taken).
	//
	// The client SHOULD prioritize these hints over the numeric priorities, but
	// MAY still use the priorities to select from ambiguous matches.
	Hints []ModelHint `json:"hints,omitempty" yaml:"hints,omitempty" mapstructure:"hints,omitempty"`

	// How much to prioritize intelligence and capabilities when selecting a
	// model. A value of 0 means intelligence is not important, while a value of 1
	// means intelligence is the most important factor.
	IntelligencePriority *float64 `json:"intelligencePriority,omitempty" yaml:"intelligencePriority,omitempty" mapstructure:"intelligencePriority,omitempty"`

	// How much to prioritize sampling speed (latency) when selecting a model. A
	// value of 0 means speed is not important, while a value of 1 means speed is
	// the most important factor.
	SpeedPriority *float64 `json:"speedPriority,omitempty" yaml:"speedPriority,omitempty" mapstructure:"speedPriority,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ModelPreferences) UnmarshalJSON(value []byte) error {
	type Plain ModelPreferences
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CostPriority != nil && 1 < *plain.CostPriority {
		return fmt.Errorf("field %s: must be <= %v", "costPriority", 1)
	}
	if plain.CostPriority != nil && 0 > *plain.CostPriority {
		return fmt.Errorf("field %s: must be >= %v", "costPriority", 0)
	}
	if plain.IntelligencePriority != nil && 1 < *plain.IntelligencePriority {
		return fmt.Errorf("field %s: must be <= %v", "intelligencePriority", 1)
	}
	if plain.IntelligencePriority != nil && 0 > *plain.IntelligencePriority {
		return fmt.Errorf("field %s: must be >= %v", "intelligencePriority", 0)
	}
	if plain.SpeedPriority != nil && 1 < *plain.SpeedPriority {
		return fmt.Errorf("field %s: must be <= %v", "speedPriority", 1)
	}
	if plain.SpeedPriority != nil && 0 > *plain.SpeedPriority {
		return fmt.Errorf("field %s: must be >= %v", "speedPriority", 0)
	}
	*j = ModelPreferences(plain)
	return nil
}

type MultiSelectEnumSchema interface{}

type Notification struct {
	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// RequestParams corresponds to the JSON schema field "params".
	RequestParams map[string]interface{} `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

type NotificationParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Notification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in Notification: required")
	}
	type Plain Notification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Notification(plain)
	return nil
}

type NumberSchema struct {
	// Default corresponds to the JSON schema field "default".
	Default *int `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Maximum corresponds to the JSON schema field "maximum".
	Maximum *int `json:"maximum,omitempty" yaml:"maximum,omitempty" mapstructure:"maximum,omitempty"`

	// Minimum corresponds to the JSON schema field "minimum".
	Minimum *int `json:"minimum,omitempty" yaml:"minimum,omitempty" mapstructure:"minimum,omitempty"`

	// Title corresponds to the JSON schema field "title".
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type NumberSchemaType `json:"type" yaml:"type" mapstructure:"type"`
}

type NumberSchemaType string

const NumberSchemaTypeInteger NumberSchemaType = "integer"
const NumberSchemaTypeNumber NumberSchemaType = "number"

var enumValues_NumberSchemaType = []interface{}{
	"integer",
	"number",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NumberSchemaType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NumberSchemaType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NumberSchemaType, v)
	}
	*j = NumberSchemaType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NumberSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NumberSchema: required")
	}
	type Plain NumberSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NumberSchema(plain)
	return nil
}

type PaginatedRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *PaginatedRequestParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// Common parameters for paginated requests.
type PaginatedRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *PaginatedRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An opaque token representing the current pagination position.
	// If provided, the server should return results starting after this cursor.
	Cursor *string `json:"cursor,omitempty" yaml:"cursor,omitempty" mapstructure:"cursor,omitempty"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type PaginatedRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaginatedRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in PaginatedRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in PaginatedRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in PaginatedRequest: required")
	}
	type Plain PaginatedRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PaginatedRequest(plain)
	return nil
}

type PaginatedResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An opaque token representing the pagination position after the last returned
	// result.
	// If present, there may be more results available.
	NextCursor *string `json:"nextCursor,omitempty" yaml:"nextCursor,omitempty" mapstructure:"nextCursor,omitempty"`
}

// A ping, issued by either the server or the client, to check that the other party
// is still alive. The receiver must promptly respond, or else may be disconnected.
type PingRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *RequestParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PingRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in PingRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in PingRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in PingRequest: required")
	}
	type Plain PingRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PingRequest(plain)
	return nil
}

// Restricted schema definitions that only allow primitive types
// without nested objects or arrays.
type PrimitiveSchemaDefinition interface{}

// An out-of-band notification used to inform the receiver of a progress update for
// a long-running request.
type ProgressNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params ProgressNotificationParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `notifications/progress` notification.
type ProgressNotificationParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An optional message describing the current progress.
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// The progress thus far. This should increase every time progress is made, even
	// if the total is unknown.
	Progress float64 `json:"progress" yaml:"progress" mapstructure:"progress"`

	// The progress token which was given in the initial request, used to associate
	// this notification with the request that is proceeding.
	ProgressToken ProgressToken `json:"progressToken" yaml:"progressToken" mapstructure:"progressToken"`

	// Total number of items to process (or total progress required), if known.
	Total *float64 `json:"total,omitempty" yaml:"total,omitempty" mapstructure:"total,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProgressNotificationParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["progress"]; raw != nil && !ok {
		return fmt.Errorf("field progress in ProgressNotificationParams: required")
	}
	if _, ok := raw["progressToken"]; raw != nil && !ok {
		return fmt.Errorf("field progressToken in ProgressNotificationParams: required")
	}
	type Plain ProgressNotificationParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProgressNotificationParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProgressNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ProgressNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ProgressNotification: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in ProgressNotification: required")
	}
	type Plain ProgressNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ProgressNotification(plain)
	return nil
}

// A progress token, used to associate progress notifications with the original
// request.
type ProgressToken int

// A prompt or prompt template that the server offers.
type Prompt struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// A list of arguments to use for templating the prompt.
	Arguments []PromptArgument `json:"arguments,omitempty" yaml:"arguments,omitempty" mapstructure:"arguments,omitempty"`

	// An optional description of what this prompt provides
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Optional set of sized icons that the client can display in a user interface.
	//
	// Clients that support rendering icons MUST support at least the following MIME
	// types:
	// - `image/png` - PNG images (safe, universal compatibility)
	// - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
	//
	// Clients that support rendering icons SHOULD also support:
	// - `image/svg+xml` - SVG images (scalable but requires security precautions)
	// - `image/webp` - WebP images (modern, efficient format)
	Icons []Icon `json:"icons,omitempty" yaml:"icons,omitempty" mapstructure:"icons,omitempty"`

	// Intended for programmatic or logical use, but used as a display name in past
	// specs or fallback (if title isn't present).
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Intended for UI and end-user contexts — optimized to be human-readable and
	// easily understood,
	// even by those unfamiliar with domain-specific terminology.
	//
	// If not provided, the name should be used for display (except for Tool,
	// where `annotations.title` should be given precedence over using `name`,
	// if present).
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`
}

// Describes an argument that a prompt can accept.
type PromptArgument struct {
	// A human-readable description of the argument.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Intended for programmatic or logical use, but used as a display name in past
	// specs or fallback (if title isn't present).
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Whether this argument must be provided.
	Required *bool `json:"required,omitempty" yaml:"required,omitempty" mapstructure:"required,omitempty"`

	// Intended for UI and end-user contexts — optimized to be human-readable and
	// easily understood,
	// even by those unfamiliar with domain-specific terminology.
	//
	// If not provided, the name should be used for display (except for Tool,
	// where `annotations.title` should be given precedence over using `name`,
	// if present).
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PromptArgument) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in PromptArgument: required")
	}
	type Plain PromptArgument
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PromptArgument(plain)
	return nil
}

// An optional notification from the server to the client, informing it that the
// list of prompts it offers has changed. This may be issued by servers without any
// previous subscription from the client.
type PromptListChangedNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *NotificationParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PromptListChangedNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in PromptListChangedNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in PromptListChangedNotification: required")
	}
	type Plain PromptListChangedNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PromptListChangedNotification(plain)
	return nil
}

// Describes a message returned as part of a prompt.
//
// This is similar to `SamplingMessage`, but also supports the embedding of
// resources from the MCP server.
type PromptMessage struct {
	// Content corresponds to the JSON schema field "content".
	Content PromptMessageContent `json:"content" yaml:"content" mapstructure:"content"`

	// Role corresponds to the JSON schema field "role".
	Role Role `json:"role" yaml:"role" mapstructure:"role"`
}

type PromptMessageContent interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PromptMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in PromptMessage: required")
	}
	if _, ok := raw["role"]; raw != nil && !ok {
		return fmt.Errorf("field role in PromptMessage: required")
	}
	type Plain PromptMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PromptMessage(plain)
	return nil
}

// Identifies a prompt.
type PromptReference struct {
	// Intended for programmatic or logical use, but used as a display name in past
	// specs or fallback (if title isn't present).
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Intended for UI and end-user contexts — optimized to be human-readable and
	// easily understood,
	// even by those unfamiliar with domain-specific terminology.
	//
	// If not provided, the name should be used for display (except for Tool,
	// where `annotations.title` should be given precedence over using `name`,
	// if present).
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PromptReference) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in PromptReference: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PromptReference: required")
	}
	type Plain PromptReference
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PromptReference(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Prompt) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Prompt: required")
	}
	type Plain Prompt
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Prompt(plain)
	return nil
}

// Sent from the client to the server, to read a specific resource URI.
type ReadResourceRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params ReadResourceRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `resources/read` request.
type ReadResourceRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *ReadResourceRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The URI of the resource. The URI can use any protocol; it is up to the server
	// how to interpret it.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type ReadResourceRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReadResourceRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in ReadResourceRequestParams: required")
	}
	type Plain ReadResourceRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ReadResourceRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReadResourceRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ReadResourceRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ReadResourceRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ReadResourceRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in ReadResourceRequest: required")
	}
	type Plain ReadResourceRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ReadResourceRequest(plain)
	return nil
}

// The server's response to a resources/read request from the client.
type ReadResourceResult struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Contents corresponds to the JSON schema field "contents".
	Contents []ReadResourceResultContentsElem `json:"contents" yaml:"contents" mapstructure:"contents"`
}

type ReadResourceResultContentsElem struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// A base64-encoded string representing the binary data of the item.
	Blob string `json:"blob" yaml:"blob" mapstructure:"blob"`

	// The MIME type of this resource, if known.
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// The text of the item. This must only be set if the item can actually be
	// represented as text (not binary data).
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// The URI of this resource.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReadResourceResultContentsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var readResourceResultContentsElem_0 TextResourceContents
	var readResourceResultContentsElem_1 BlobResourceContents
	var errs []error
	if err := readResourceResultContentsElem_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := readResourceResultContentsElem_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 2 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain ReadResourceResultContentsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ReadResourceResultContentsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReadResourceResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["contents"]; raw != nil && !ok {
		return fmt.Errorf("field contents in ReadResourceResult: required")
	}
	type Plain ReadResourceResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ReadResourceResult(plain)
	return nil
}

// Metadata for associating messages with a task.
// Include this in the `_meta` field under the key
// `io.modelcontextprotocol/related-task`.
type RelatedTaskMetadata struct {
	// The task identifier this message is associated with.
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RelatedTaskMetadata) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["taskId"]; raw != nil && !ok {
		return fmt.Errorf("field taskId in RelatedTaskMetadata: required")
	}
	type Plain RelatedTaskMetadata
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RelatedTaskMetadata(plain)
	return nil
}

type Request struct {
	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// RequestParams corresponds to the JSON schema field "params".
	RequestParams map[string]interface{} `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// A uniquely identifying ID for a request in JSON-RPC.
type RequestId int

// Common params for any request.
type RequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *RequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`
}

// Backward-compat aliases for legacy request param names.
type PingRequestParams = RequestParams
type ListRootsRequestParams = RequestParams
type ListResourcesRequestParams = PaginatedRequestParams
type ListResourceTemplatesRequestParams = PaginatedRequestParams
type ListPromptsRequestParams = PaginatedRequestParams
type ListToolsRequestParams = PaginatedRequestParams

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type RequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Request) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in Request: required")
	}
	type Plain Request
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Request(plain)
	return nil
}

// A known resource that the server is capable of reading.
type Resource struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Optional annotations for the client.
	Annotations *Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// A description of what this resource represents.
	//
	// This can be used by clients to improve the LLM's understanding of available
	// resources. It can be thought of like a "hint" to the model.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Optional set of sized icons that the client can display in a user interface.
	//
	// Clients that support rendering icons MUST support at least the following MIME
	// types:
	// - `image/png` - PNG images (safe, universal compatibility)
	// - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
	//
	// Clients that support rendering icons SHOULD also support:
	// - `image/svg+xml` - SVG images (scalable but requires security precautions)
	// - `image/webp` - WebP images (modern, efficient format)
	Icons []Icon `json:"icons,omitempty" yaml:"icons,omitempty" mapstructure:"icons,omitempty"`

	// The MIME type of this resource, if known.
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// Intended for programmatic or logical use, but used as a display name in past
	// specs or fallback (if title isn't present).
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The size of the raw resource content, in bytes (i.e., before base64 encoding or
	// any tokenization), if known.
	//
	// This can be used by Hosts to display file sizes and estimate context window
	// usage.
	Size *int `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// Intended for UI and end-user contexts — optimized to be human-readable and
	// easily understood,
	// even by those unfamiliar with domain-specific terminology.
	//
	// If not provided, the name should be used for display (except for Tool,
	// where `annotations.title` should be given precedence over using `name`,
	// if present).
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// The URI of this resource.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// The contents of a specific resource or sub-resource.
type ResourceContents struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The MIME type of this resource, if known.
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// The URI of this resource.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceContents) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in ResourceContents: required")
	}
	type Plain ResourceContents
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResourceContents(plain)
	return nil
}

// A resource that the server is capable of reading, included in a prompt or tool
// call result.
//
// Note: resource links returned by tools are not guaranteed to appear in the
// results of `resources/list` requests.
type ResourceLink struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Optional annotations for the client.
	Annotations *Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// A description of what this resource represents.
	//
	// This can be used by clients to improve the LLM's understanding of available
	// resources. It can be thought of like a "hint" to the model.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Optional set of sized icons that the client can display in a user interface.
	//
	// Clients that support rendering icons MUST support at least the following MIME
	// types:
	// - `image/png` - PNG images (safe, universal compatibility)
	// - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
	//
	// Clients that support rendering icons SHOULD also support:
	// - `image/svg+xml` - SVG images (scalable but requires security precautions)
	// - `image/webp` - WebP images (modern, efficient format)
	Icons []Icon `json:"icons,omitempty" yaml:"icons,omitempty" mapstructure:"icons,omitempty"`

	// The MIME type of this resource, if known.
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// Intended for programmatic or logical use, but used as a display name in past
	// specs or fallback (if title isn't present).
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The size of the raw resource content, in bytes (i.e., before base64 encoding or
	// any tokenization), if known.
	//
	// This can be used by Hosts to display file sizes and estimate context window
	// usage.
	Size *int `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// Intended for UI and end-user contexts — optimized to be human-readable and
	// easily understood,
	// even by those unfamiliar with domain-specific terminology.
	//
	// If not provided, the name should be used for display (except for Tool,
	// where `annotations.title` should be given precedence over using `name`,
	// if present).
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// The URI of this resource.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceLink) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ResourceLink: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ResourceLink: required")
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in ResourceLink: required")
	}
	type Plain ResourceLink
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResourceLink(plain)
	return nil
}

// An optional notification from the server to the client, informing it that the
// list of resources it can read from has changed. This may be issued by servers
// without any previous subscription from the client.
type ResourceListChangedNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *NotificationParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceListChangedNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ResourceListChangedNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ResourceListChangedNotification: required")
	}
	type Plain ResourceListChangedNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResourceListChangedNotification(plain)
	return nil
}

// Common parameters when working with resources.
type ResourceRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *ResourceRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The URI of the resource. The URI can use any protocol; it is up to the server
	// how to interpret it.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type ResourceRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in ResourceRequestParams: required")
	}
	type Plain ResourceRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResourceRequestParams(plain)
	return nil
}

// A template description for resources available on the server.
type ResourceTemplate struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Optional annotations for the client.
	Annotations *Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// A description of what this template is for.
	//
	// This can be used by clients to improve the LLM's understanding of available
	// resources. It can be thought of like a "hint" to the model.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Optional set of sized icons that the client can display in a user interface.
	//
	// Clients that support rendering icons MUST support at least the following MIME
	// types:
	// - `image/png` - PNG images (safe, universal compatibility)
	// - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
	//
	// Clients that support rendering icons SHOULD also support:
	// - `image/svg+xml` - SVG images (scalable but requires security precautions)
	// - `image/webp` - WebP images (modern, efficient format)
	Icons []Icon `json:"icons,omitempty" yaml:"icons,omitempty" mapstructure:"icons,omitempty"`

	// The MIME type for all resources that match this template. This should only be
	// included if all resources matching this template have the same type.
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// Intended for programmatic or logical use, but used as a display name in past
	// specs or fallback (if title isn't present).
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Intended for UI and end-user contexts — optimized to be human-readable and
	// easily understood,
	// even by those unfamiliar with domain-specific terminology.
	//
	// If not provided, the name should be used for display (except for Tool,
	// where `annotations.title` should be given precedence over using `name`,
	// if present).
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// A URI template (according to RFC 6570) that can be used to construct resource
	// URIs.
	UriTemplate string `json:"uriTemplate" yaml:"uriTemplate" mapstructure:"uriTemplate"`
}

// A reference to a resource or resource template definition.
type ResourceTemplateReference struct {
	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// The URI or URI template of the resource.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceTemplateReference) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ResourceTemplateReference: required")
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in ResourceTemplateReference: required")
	}
	type Plain ResourceTemplateReference
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResourceTemplateReference(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceTemplate) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ResourceTemplate: required")
	}
	if _, ok := raw["uriTemplate"]; raw != nil && !ok {
		return fmt.Errorf("field uriTemplate in ResourceTemplate: required")
	}
	type Plain ResourceTemplate
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResourceTemplate(plain)
	return nil
}

// A notification from the server to the client, informing it that a resource has
// changed and may need to be read again. This should only be sent if the client
// previously sent a resources/subscribe request.
type ResourceUpdatedNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params ResourceUpdatedNotificationParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `notifications/resources/updated` notification.
type ResourceUpdatedNotificationParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The URI of the resource that has been updated. This might be a sub-resource of
	// the one that the client actually subscribed to.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceUpdatedNotificationParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in ResourceUpdatedNotificationParams: required")
	}
	type Plain ResourceUpdatedNotificationParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResourceUpdatedNotificationParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceUpdatedNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ResourceUpdatedNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ResourceUpdatedNotification: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in ResourceUpdatedNotification: required")
	}
	type Plain ResourceUpdatedNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ResourceUpdatedNotification(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Resource) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Resource: required")
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in Resource: required")
	}
	type Plain Resource
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Resource(plain)
	return nil
}

type Result struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type Role string

const RoleAssistant Role = "assistant"
const RoleUser Role = "user"

var enumValues_Role = []interface{}{
	"assistant",
	"user",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Role) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Role {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Role, v)
	}
	*j = Role(v)
	return nil
}

// Represents a root directory or file that the server can operate on.
type Root struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// An optional name for the root. This can be used to provide a human-readable
	// identifier for the root, which may be useful for display purposes or for
	// referencing the root in other parts of the application.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The URI identifying the root. This *must* start with file:// for now.
	// This restriction may be relaxed in future versions of the protocol to allow
	// other URI schemes.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Root) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in Root: required")
	}
	type Plain Root
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Root(plain)
	return nil
}

// A notification from the client to the server, informing it that the list of
// roots has changed.
// This notification should be sent whenever the client adds, removes, or modifies
// any root.
// The server should then request an updated list of roots using the
// ListRootsRequest.
type RootsListChangedNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *NotificationParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RootsListChangedNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in RootsListChangedNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in RootsListChangedNotification: required")
	}
	type Plain RootsListChangedNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RootsListChangedNotification(plain)
	return nil
}

// Describes a message issued to or received from an LLM API.
type SamplingMessage struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Content corresponds to the JSON schema field "content".
	Content SamplingMessageContent `json:"content" yaml:"content" mapstructure:"content"`

	// Role corresponds to the JSON schema field "role".
	Role Role `json:"role" yaml:"role" mapstructure:"role"`
}

// Text provided to or from an LLM.
type SamplingMessageContent struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Optional annotations for the client.
	Annotations *Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// The unstructured result content of the tool use.
	//
	// This has the same format as CallToolResult.content and can include text,
	// images,
	// audio, resource links, and embedded resources.
	Content []ToolResultContentContentElem `json:"content" yaml:"content" mapstructure:"content"`

	// The base64-encoded image data.
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// A unique identifier for this tool use.
	//
	// This ID is used to match tool results to their corresponding tool uses.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The arguments to pass to the tool, conforming to the tool's input schema.
	Input map[string]interface{} `json:"input" yaml:"input" mapstructure:"input"`

	// Whether the tool use resulted in an error.
	//
	// If true, the content typically describes the error that occurred.
	// Default: false
	IsError *bool `json:"isError,omitempty" yaml:"isError,omitempty" mapstructure:"isError,omitempty"`

	// The MIME type of the image. Different providers may support different image
	// types.
	MimeType string `json:"mimeType" yaml:"mimeType" mapstructure:"mimeType"`

	// The name of the tool to call.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// An optional structured result object.
	//
	// If the tool defined an outputSchema, this SHOULD conform to that schema.
	StructuredContent map[string]interface{} `json:"structuredContent,omitempty" yaml:"structuredContent,omitempty" mapstructure:"structuredContent,omitempty"`

	// The text content of the message.
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// The ID of the tool use this result corresponds to.
	//
	// This MUST match the ID from a previous ToolUseContent.
	ToolUseId string `json:"toolUseId" yaml:"toolUseId" mapstructure:"toolUseId"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type SamplingMessageContentBlock interface{}

type SamplingMessageContent_5Elem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SamplingMessageContent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	var samplingMessageContent_0 TextContent
	var samplingMessageContent_1 ImageContent
	var samplingMessageContent_2 AudioContent
	var samplingMessageContent_3 ToolUseContent
	var samplingMessageContent_4 ToolResultContent
	var errs []error
	if err := samplingMessageContent_0.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := samplingMessageContent_1.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := samplingMessageContent_2.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := samplingMessageContent_3.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if err := samplingMessageContent_4.UnmarshalJSON(value); err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 6 {
		return fmt.Errorf("all validators failed: %s", errors.Join(errs...))
	}
	type Plain SamplingMessageContent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SamplingMessageContent(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SamplingMessage) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in SamplingMessage: required")
	}
	if _, ok := raw["role"]; raw != nil && !ok {
		return fmt.Errorf("field role in SamplingMessage: required")
	}
	type Plain SamplingMessage
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SamplingMessage(plain)
	return nil
}

// Capabilities that a server may support. Known capabilities are defined here, in
// this schema, but this is not a closed set: any server can define its own,
// additional capabilities.
type ServerCapabilities struct {
	// Present if the server supports argument autocompletion suggestions.
	Completions map[string]interface{} `json:"completions,omitempty" yaml:"completions,omitempty" mapstructure:"completions,omitempty"`

	// Experimental, non-standard capabilities that the server supports.
	Experimental map[string]map[string]interface{} `json:"experimental,omitempty" yaml:"experimental,omitempty" mapstructure:"experimental,omitempty"`

	// Present if the server supports sending log messages to the client.
	Logging map[string]interface{} `json:"logging,omitempty" yaml:"logging,omitempty" mapstructure:"logging,omitempty"`

	// Present if the server offers any prompt templates.
	Prompts *ServerCapabilitiesPrompts `json:"prompts,omitempty" yaml:"prompts,omitempty" mapstructure:"prompts,omitempty"`

	// Present if the server offers any resources to read.
	Resources *ServerCapabilitiesResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Present if the server supports task-augmented requests.
	Tasks *ServerCapabilitiesTasks `json:"tasks,omitempty" yaml:"tasks,omitempty" mapstructure:"tasks,omitempty"`

	// Present if the server offers any tools to call.
	Tools *ServerCapabilitiesTools `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

// Present if the server offers any prompt templates.
type ServerCapabilitiesPrompts struct {
	// Whether this server supports notifications for changes to the prompt list.
	ListChanged *bool `json:"listChanged,omitempty" yaml:"listChanged,omitempty" mapstructure:"listChanged,omitempty"`
}

// Present if the server offers any resources to read.
type ServerCapabilitiesResources struct {
	// Whether this server supports notifications for changes to the resource list.
	ListChanged *bool `json:"listChanged,omitempty" yaml:"listChanged,omitempty" mapstructure:"listChanged,omitempty"`

	// Whether this server supports subscribing to resource updates.
	Subscribe *bool `json:"subscribe,omitempty" yaml:"subscribe,omitempty" mapstructure:"subscribe,omitempty"`
}

// Present if the server supports task-augmented requests.
type ServerCapabilitiesTasks struct {
	// Whether this server supports tasks/cancel.
	Cancel map[string]interface{} `json:"cancel,omitempty" yaml:"cancel,omitempty" mapstructure:"cancel,omitempty"`

	// Whether this server supports tasks/list.
	List map[string]interface{} `json:"list,omitempty" yaml:"list,omitempty" mapstructure:"list,omitempty"`

	// Specifies which request types can be augmented with tasks.
	Requests *ServerCapabilitiesTasksRequests `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

// Specifies which request types can be augmented with tasks.
type ServerCapabilitiesTasksRequests struct {
	// Task support for tool-related requests.
	Tools *ServerCapabilitiesTasksRequestsTools `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

// Task support for tool-related requests.
type ServerCapabilitiesTasksRequestsTools struct {
	// Whether the server supports task-augmented tools/call requests.
	Call map[string]interface{} `json:"call,omitempty" yaml:"call,omitempty" mapstructure:"call,omitempty"`
}

// Present if the server offers any tools to call.
type ServerCapabilitiesTools struct {
	// Whether this server supports notifications for changes to the tool list.
	ListChanged *bool `json:"listChanged,omitempty" yaml:"listChanged,omitempty" mapstructure:"listChanged,omitempty"`
}

type ServerNotification interface{}

type ServerRequest interface{}

type ServerResult interface{}

// A request from the client to the server, to enable or adjust logging.
type SetLevelRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params SetLevelRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `logging/setLevel` request.
type SetLevelRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *SetLevelRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The level of logging that the client wants to receive from the server. The
	// server should send all logs at this level and higher (i.e., more severe) to the
	// client as notifications/message.
	Level LoggingLevel `json:"level" yaml:"level" mapstructure:"level"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type SetLevelRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetLevelRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in SetLevelRequestParams: required")
	}
	type Plain SetLevelRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SetLevelRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetLevelRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SetLevelRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in SetLevelRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in SetLevelRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in SetLevelRequest: required")
	}
	type Plain SetLevelRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SetLevelRequest(plain)
	return nil
}

type SingleSelectEnumSchema interface{}

type StringSchema struct {
	// Default corresponds to the JSON schema field "default".
	Default *string `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Format corresponds to the JSON schema field "format".
	Format *StringSchemaFormat `json:"format,omitempty" yaml:"format,omitempty" mapstructure:"format,omitempty"`

	// MaxLength corresponds to the JSON schema field "maxLength".
	MaxLength *int `json:"maxLength,omitempty" yaml:"maxLength,omitempty" mapstructure:"maxLength,omitempty"`

	// MinLength corresponds to the JSON schema field "minLength".
	MinLength *int `json:"minLength,omitempty" yaml:"minLength,omitempty" mapstructure:"minLength,omitempty"`

	// Title corresponds to the JSON schema field "title".
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type StringSchemaFormat string

const StringSchemaFormatDate StringSchemaFormat = "date"
const StringSchemaFormatDateTime StringSchemaFormat = "date-time"
const StringSchemaFormatEmail StringSchemaFormat = "email"
const StringSchemaFormatUri StringSchemaFormat = "uri"

var enumValues_StringSchemaFormat = []interface{}{
	"date",
	"date-time",
	"email",
	"uri",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StringSchemaFormat) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StringSchemaFormat {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StringSchemaFormat, v)
	}
	*j = StringSchemaFormat(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StringSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in StringSchema: required")
	}
	type Plain StringSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = StringSchema(plain)
	return nil
}

// Sent from the client to request resources/updated notifications from the server
// whenever a particular resource changes.
type SubscribeRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params SubscribeRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `resources/subscribe` request.
type SubscribeRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *SubscribeRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The URI of the resource. The URI can use any protocol; it is up to the server
	// how to interpret it.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type SubscribeRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscribeRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in SubscribeRequestParams: required")
	}
	type Plain SubscribeRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SubscribeRequestParams(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscribeRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SubscribeRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in SubscribeRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in SubscribeRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in SubscribeRequest: required")
	}
	type Plain SubscribeRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SubscribeRequest(plain)
	return nil
}

// Data associated with a task.
type Task struct {
	// ISO 8601 timestamp when the task was created.
	CreatedAt string `json:"createdAt" yaml:"createdAt" mapstructure:"createdAt"`

	// ISO 8601 timestamp when the task was last updated.
	LastUpdatedAt string `json:"lastUpdatedAt" yaml:"lastUpdatedAt" mapstructure:"lastUpdatedAt"`

	// Suggested polling interval in milliseconds.
	PollInterval *int `json:"pollInterval,omitempty" yaml:"pollInterval,omitempty" mapstructure:"pollInterval,omitempty"`

	// Current task state.
	Status TaskStatus `json:"status" yaml:"status" mapstructure:"status"`

	// Optional human-readable message describing the current task state.
	// This can provide context for any status, including:
	// - Reasons for "cancelled" status
	// - Summaries for "completed" status
	// - Diagnostic information for "failed" status (e.g., error details, what went
	// wrong)
	StatusMessage *string `json:"statusMessage,omitempty" yaml:"statusMessage,omitempty" mapstructure:"statusMessage,omitempty"`

	// The task identifier.
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`

	// Actual retention duration from creation in milliseconds, null for unlimited.
	Ttl int `json:"ttl" yaml:"ttl" mapstructure:"ttl"`
}

// Common params for any task-augmented request.
type TaskAugmentedRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *TaskAugmentedRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// If specified, the caller is requesting task-augmented execution for this
	// request.
	// The request will return a CreateTaskResult immediately, and the actual result
	// can be
	// retrieved later via tasks/result.
	//
	// Task augmentation is subject to capability negotiation - receivers MUST declare
	// support
	// for task augmentation of specific request types in their capabilities.
	Task *TaskMetadata `json:"task,omitempty" yaml:"task,omitempty" mapstructure:"task,omitempty"`
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type TaskAugmentedRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// Metadata for augmenting a request with task execution.
// Include this in the `task` field of the request parameters.
type TaskMetadata struct {
	// Requested duration in milliseconds to retain task from creation.
	Ttl *int `json:"ttl,omitempty" yaml:"ttl,omitempty" mapstructure:"ttl,omitempty"`
}

type TaskStatus string

const TaskStatusCancelled TaskStatus = "cancelled"
const TaskStatusCompleted TaskStatus = "completed"
const TaskStatusFailed TaskStatus = "failed"
const TaskStatusInputRequired TaskStatus = "input_required"

// An optional notification from the receiver to the requestor, informing them that
// a task's status has changed. Receivers are not required to send these
// notifications.
type TaskStatusNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// TaskStatusNotificationParams corresponds to the JSON schema field
	// "params".
	TaskStatusNotificationParams TaskStatusNotificationTaskStatusNotificationParams `json:"params" yaml:"params" mapstructure:"params"`
}

// Parameters for a `notifications/tasks/status` notification.
type TaskStatusNotificationParams interface{}

type TaskStatusNotificationTaskStatusNotificationParams interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskStatusNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in TaskStatusNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in TaskStatusNotification: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in TaskStatusNotification: required")
	}
	type Plain TaskStatusNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TaskStatusNotification(plain)
	return nil
}

const TaskStatusWorking TaskStatus = "working"

var enumValues_TaskStatus = []interface{}{
	"cancelled",
	"completed",
	"failed",
	"input_required",
	"working",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskStatus) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TaskStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TaskStatus, v)
	}
	*j = TaskStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Task) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["createdAt"]; raw != nil && !ok {
		return fmt.Errorf("field createdAt in Task: required")
	}
	if _, ok := raw["lastUpdatedAt"]; raw != nil && !ok {
		return fmt.Errorf("field lastUpdatedAt in Task: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in Task: required")
	}
	if _, ok := raw["taskId"]; raw != nil && !ok {
		return fmt.Errorf("field taskId in Task: required")
	}
	if _, ok := raw["ttl"]; raw != nil && !ok {
		return fmt.Errorf("field ttl in Task: required")
	}
	type Plain Task
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Task(plain)
	return nil
}

// Text provided to or from an LLM.
type TextContent struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Optional annotations for the client.
	Annotations *Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// The text content of the message.
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TextContent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in TextContent: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TextContent: required")
	}
	type Plain TextContent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TextContent(plain)
	return nil
}

type TextResourceContents struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The MIME type of this resource, if known.
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// The text of the item. This must only be set if the item can actually be
	// represented as text (not binary data).
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// The URI of this resource.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TextResourceContents) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in TextResourceContents: required")
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in TextResourceContents: required")
	}
	type Plain TextResourceContents
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TextResourceContents(plain)
	return nil
}

// Schema for multiple-selection enumeration with display titles for each option.
type TitledMultiSelectEnumSchema struct {
	// Optional default value.
	Default []string `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// Optional description for the enum field.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Schema for array items with enum options and display labels.
	Items TitledMultiSelectEnumSchemaItems `json:"items" yaml:"items" mapstructure:"items"`

	// Maximum number of items to select.
	MaxItems *int `json:"maxItems,omitempty" yaml:"maxItems,omitempty" mapstructure:"maxItems,omitempty"`

	// Minimum number of items to select.
	MinItems *int `json:"minItems,omitempty" yaml:"minItems,omitempty" mapstructure:"minItems,omitempty"`

	// Optional title for the enum field.
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// Schema for array items with enum options and display labels.
type TitledMultiSelectEnumSchemaItems struct {
	// Array of enum options with values and display labels.
	AnyOf []TitledMultiSelectEnumSchemaItemsAnyOfElem `json:"anyOf" yaml:"anyOf" mapstructure:"anyOf"`
}

type TitledMultiSelectEnumSchemaItemsAnyOfElem struct {
	// The constant enum value.
	Const string `json:"const" yaml:"const" mapstructure:"const"`

	// Display title for this option.
	Title string `json:"title" yaml:"title" mapstructure:"title"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tool) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["inputSchema"]; raw != nil && !ok {
		return fmt.Errorf("field inputSchema in Tool: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Tool: required")
	}
	type Plain Tool
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Tool(plain)
	return nil
}

// Definition for a tool the client can call.
type Tool struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// Optional additional tool information.
	//
	// Display name precedence order is: title, annotations.title, then name.
	Annotations *ToolAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// A human-readable description of the tool.
	//
	// This can be used by clients to improve the LLM's understanding of available
	// tools. It can be thought of like a "hint" to the model.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Execution-related properties for this tool.
	Execution *ToolExecution `json:"execution,omitempty" yaml:"execution,omitempty" mapstructure:"execution,omitempty"`

	// Optional set of sized icons that the client can display in a user interface.
	//
	// Clients that support rendering icons MUST support at least the following MIME
	// types:
	// - `image/png` - PNG images (safe, universal compatibility)
	// - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
	//
	// Clients that support rendering icons SHOULD also support:
	// - `image/svg+xml` - SVG images (scalable but requires security precautions)
	// - `image/webp` - WebP images (modern, efficient format)
	Icons []Icon `json:"icons,omitempty" yaml:"icons,omitempty" mapstructure:"icons,omitempty"`

	// A JSON Schema object defining the expected parameters for the tool.
	InputSchema ToolInputSchema `json:"inputSchema" yaml:"inputSchema" mapstructure:"inputSchema"`

	// Intended for programmatic or logical use, but used as a display name in past
	// specs or fallback (if title isn't present).
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// An optional JSON Schema object defining the structure of the tool's output
	// returned in
	// the structuredContent field of a CallToolResult.
	//
	// Defaults to JSON Schema 2020-12 when no explicit $schema is provided.
	// Currently restricted to type: "object" at the root level.
	OutputSchema *ToolOutputSchema `json:"outputSchema,omitempty" yaml:"outputSchema,omitempty" mapstructure:"outputSchema,omitempty"`

	// Intended for UI and end-user contexts — optimized to be human-readable and
	// easily understood,
	// even by those unfamiliar with domain-specific terminology.
	//
	// If not provided, the name should be used for display (except for Tool,
	// where `annotations.title` should be given precedence over using `name`,
	// if present).
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolOutputSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ToolOutputSchema: required")
	}
	type Plain ToolOutputSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolOutputSchema(plain)
	return nil
}

// An optional JSON Schema object defining the structure of the tool's output
// returned in
// the structuredContent field of a CallToolResult.
//
// Defaults to JSON Schema 2020-12 when no explicit $schema is provided.
// Currently restricted to type: "object" at the root level.
type ToolOutputSchema struct {
	// Schema corresponds to the JSON schema field "$schema".
	Schema *string `json:"$schema,omitempty" yaml:"$schema,omitempty" mapstructure:"$schema,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties map[string]map[string]interface{} `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// Required corresponds to the JSON schema field "required".
	Required []string `json:"required,omitempty" yaml:"required,omitempty" mapstructure:"required,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolInputSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ToolInputSchema: required")
	}
	type Plain ToolInputSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolInputSchema(plain)
	return nil
}

// A JSON Schema object defining the expected parameters for the tool.
type ToolInputSchema struct {
	// Schema corresponds to the JSON schema field "$schema".
	Schema *string `json:"$schema,omitempty" yaml:"$schema,omitempty" mapstructure:"$schema,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties map[string]map[string]interface{} `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// Required corresponds to the JSON schema field "required".
	Required []string `json:"required,omitempty" yaml:"required,omitempty" mapstructure:"required,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// ToolInputSchemaProperties represents the properties map for a tool input schema.
type ToolInputSchemaProperties map[string]map[string]interface{}

// Execution-related properties for a tool.
type ToolExecution struct {
	// Indicates whether this tool supports task-augmented execution.
	// This allows clients to handle long-running operations through polling
	// the task system.
	//
	// - "forbidden": Tool does not support task-augmented execution (default when
	// absent)
	// - "optional": Tool may support task-augmented execution
	// - "required": Tool requires task-augmented execution
	//
	// Default: "forbidden"
	TaskSupport *ToolExecutionTaskSupport `json:"taskSupport,omitempty" yaml:"taskSupport,omitempty" mapstructure:"taskSupport,omitempty"`
}

const ToolExecutionTaskSupportRequired ToolExecutionTaskSupport = "required"
const ToolExecutionTaskSupportOptional ToolExecutionTaskSupport = "optional"
const ToolExecutionTaskSupportForbidden ToolExecutionTaskSupport = "forbidden"

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolExecutionTaskSupport) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolExecutionTaskSupport {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolExecutionTaskSupport, v)
	}
	*j = ToolExecutionTaskSupport(v)
	return nil
}

var enumValues_ToolExecutionTaskSupport = []interface{}{
	"forbidden",
	"optional",
	"required",
}

type ToolExecutionTaskSupport string

// Additional properties describing a Tool to clients.
//
// NOTE: all properties in ToolAnnotations are **hints**.
// They are not guaranteed to provide a faithful description of
// tool behavior (including descriptive properties like `title`).
//
// Clients should never make tool use decisions based on ToolAnnotations
// received from untrusted servers.
type ToolAnnotations struct {
	// If true, the tool may perform destructive updates to its environment.
	// If false, the tool performs only additive updates.
	//
	// (This property is meaningful only when `readOnlyHint == false`)
	//
	// Default: true
	DestructiveHint *bool `json:"destructiveHint,omitempty" yaml:"destructiveHint,omitempty" mapstructure:"destructiveHint,omitempty"`

	// If true, calling the tool repeatedly with the same arguments
	// will have no additional effect on its environment.
	//
	// (This property is meaningful only when `readOnlyHint == false`)
	//
	// Default: false
	IdempotentHint *bool `json:"idempotentHint,omitempty" yaml:"idempotentHint,omitempty" mapstructure:"idempotentHint,omitempty"`

	// If true, this tool may interact with an "open world" of external
	// entities. If false, the tool's domain of interaction is closed.
	// For example, the world of a web search tool is open, whereas that
	// of a memory tool is not.
	//
	// Default: true
	OpenWorldHint *bool `json:"openWorldHint,omitempty" yaml:"openWorldHint,omitempty" mapstructure:"openWorldHint,omitempty"`

	// If true, the tool does not modify its environment.
	//
	// Default: false
	ReadOnlyHint *bool `json:"readOnlyHint,omitempty" yaml:"readOnlyHint,omitempty" mapstructure:"readOnlyHint,omitempty"`

	// A human-readable title for the tool.
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`
}

// Controls tool selection behavior for sampling requests.
type ToolChoice struct {
	// Controls the tool use ability of the model:
	// - "auto": Model decides whether to use tools (default)
	// - "required": Model MUST use at least one tool before completing
	// - "none": Model MUST NOT use any tools
	Mode *ToolChoiceMode `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`
}

const ToolChoiceModeRequired ToolChoiceMode = "required"
const ToolChoiceModeNone ToolChoiceMode = "none"
const ToolChoiceModeAuto ToolChoiceMode = "auto"

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolChoiceMode) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolChoiceMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolChoiceMode, v)
	}
	*j = ToolChoiceMode(v)
	return nil
}

var enumValues_ToolChoiceMode = []interface{}{
	"auto",
	"none",
	"required",
}

type ToolChoiceMode string

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolResultContent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in ToolResultContent: required")
	}
	if _, ok := raw["toolUseId"]; raw != nil && !ok {
		return fmt.Errorf("field toolUseId in ToolResultContent: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ToolResultContent: required")
	}
	type Plain ToolResultContent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolResultContent(plain)
	return nil
}

// The result of a tool use, provided by the user back to the assistant.
type ToolResultContent struct {
	// Optional metadata about the tool result. Clients SHOULD preserve this field
	// when
	// including tool results in subsequent sampling requests to enable caching
	// optimizations.
	//
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The unstructured result content of the tool use.
	//
	// This has the same format as CallToolResult.content and can include text,
	// images,
	// audio, resource links, and embedded resources.
	Content []ToolResultContentContentElem `json:"content" yaml:"content" mapstructure:"content"`

	// Whether the tool use resulted in an error.
	//
	// If true, the content typically describes the error that occurred.
	// Default: false
	IsError *bool `json:"isError,omitempty" yaml:"isError,omitempty" mapstructure:"isError,omitempty"`

	// An optional structured result object.
	//
	// If the tool defined an outputSchema, this SHOULD conform to that schema.
	StructuredContent map[string]interface{} `json:"structuredContent,omitempty" yaml:"structuredContent,omitempty" mapstructure:"structuredContent,omitempty"`

	// The ID of the tool use this result corresponds to.
	//
	// This MUST match the ID from a previous ToolUseContent.
	ToolUseId string `json:"toolUseId" yaml:"toolUseId" mapstructure:"toolUseId"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type ToolResultContentContentElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolUseContent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolUseContent: required")
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolUseContent: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolUseContent: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ToolUseContent: required")
	}
	type Plain ToolUseContent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolUseContent(plain)
	return nil
}

// A request from the assistant to call a tool.
type ToolUseContent struct {
	// Optional metadata about the tool use. Clients SHOULD preserve this field when
	// including tool uses in subsequent sampling requests to enable caching
	// optimizations.
	//
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta map[string]interface{} `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// A unique identifier for this tool use.
	//
	// This ID is used to match tool results to their corresponding tool uses.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The arguments to pass to the tool, conforming to the tool's input schema.
	Input map[string]interface{} `json:"input" yaml:"input" mapstructure:"input"`

	// The name of the tool to call.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TitledMultiSelectEnumSchemaItemsAnyOfElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["const"]; raw != nil && !ok {
		return fmt.Errorf("field const in TitledMultiSelectEnumSchemaItemsAnyOfElem: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in TitledMultiSelectEnumSchemaItemsAnyOfElem: required")
	}
	type Plain TitledMultiSelectEnumSchemaItemsAnyOfElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TitledMultiSelectEnumSchemaItemsAnyOfElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TitledMultiSelectEnumSchemaItems) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["anyOf"]; raw != nil && !ok {
		return fmt.Errorf("field anyOf in TitledMultiSelectEnumSchemaItems: required")
	}
	type Plain TitledMultiSelectEnumSchemaItems
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TitledMultiSelectEnumSchemaItems(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TitledMultiSelectEnumSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["items"]; raw != nil && !ok {
		return fmt.Errorf("field items in TitledMultiSelectEnumSchema: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TitledMultiSelectEnumSchema: required")
	}
	type Plain TitledMultiSelectEnumSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TitledMultiSelectEnumSchema(plain)
	return nil
}

type TitledSingleSelectEnumSchemaOneOfElem struct {
	// The enum value.
	Const string `json:"const" yaml:"const" mapstructure:"const"`

	// Display label for this option.
	Title string `json:"title" yaml:"title" mapstructure:"title"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TitledSingleSelectEnumSchemaOneOfElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["const"]; raw != nil && !ok {
		return fmt.Errorf("field const in TitledSingleSelectEnumSchemaOneOfElem: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in TitledSingleSelectEnumSchemaOneOfElem: required")
	}
	type Plain TitledSingleSelectEnumSchemaOneOfElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TitledSingleSelectEnumSchemaOneOfElem(plain)
	return nil
}

// Schema for single-selection enumeration with display titles for each option.
type TitledSingleSelectEnumSchema struct {
	// Optional default value.
	Default *string `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// Optional description for the enum field.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Array of enum options with values and display labels.
	OneOf []TitledSingleSelectEnumSchemaOneOfElem `json:"oneOf" yaml:"oneOf" mapstructure:"oneOf"`

	// Optional title for the enum field.
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TitledSingleSelectEnumSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["oneOf"]; raw != nil && !ok {
		return fmt.Errorf("field oneOf in TitledSingleSelectEnumSchema: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TitledSingleSelectEnumSchema: required")
	}
	type Plain TitledSingleSelectEnumSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TitledSingleSelectEnumSchema(plain)
	return nil
}

// An optional notification from the server to the client, informing it that the
// list of tools it offers has changed. This may be issued by servers without any
// previous subscription from the client.
type ToolListChangedNotification struct {
	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params *NotificationParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolListChangedNotification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in ToolListChangedNotification: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ToolListChangedNotification: required")
	}
	type Plain ToolListChangedNotification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolListChangedNotification(plain)
	return nil
}

// Additional information about the error. The value of this member is defined by
// the sender (e.g. detailed error information, nested errors etc.).
type URLElicitationRequiredErrorErrorData struct {
	// Elicitations corresponds to the JSON schema field "elicitations".
	Elicitations []ElicitRequestURLParams `json:"elicitations" yaml:"elicitations" mapstructure:"elicitations"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *URLElicitationRequiredErrorErrorData) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["elicitations"]; raw != nil && !ok {
		return fmt.Errorf("field elicitations in URLElicitationRequiredErrorErrorData: required")
	}
	type Plain URLElicitationRequiredErrorErrorData
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = URLElicitationRequiredErrorErrorData(plain)
	return nil
}

type URLElicitationRequiredErrorError struct {
	// The error type that occurred.
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// Additional information about the error. The value of this member is defined by
	// the sender (e.g. detailed error information, nested errors etc.).
	Data URLElicitationRequiredErrorErrorData `json:"data" yaml:"data" mapstructure:"data"`

	// A short description of the error. The message SHOULD be limited to a concise
	// single sentence.
	Message string `json:"message" yaml:"message" mapstructure:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *URLElicitationRequiredErrorError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in URLElicitationRequiredErrorError: required")
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in URLElicitationRequiredErrorError: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in URLElicitationRequiredErrorError: required")
	}
	type Plain URLElicitationRequiredErrorError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = URLElicitationRequiredErrorError(plain)
	return nil
}

// An error response that indicates that the server requires the client to provide
// additional information via an elicitation request.
type URLElicitationRequiredError struct {
	// Error corresponds to the JSON schema field "error".
	Error URLElicitationRequiredErrorError `json:"error" yaml:"error" mapstructure:"error"`

	// Id corresponds to the JSON schema field "id".
	Id *RequestId `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *URLElicitationRequiredError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["error"]; raw != nil && !ok {
		return fmt.Errorf("field error in URLElicitationRequiredError: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in URLElicitationRequiredError: required")
	}
	type Plain URLElicitationRequiredError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = URLElicitationRequiredError(plain)
	return nil
}

// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
// notes on `_meta` usage.
type UnsubscribeRequestParamsMeta struct {
	// If specified, the caller is requesting out-of-band progress notifications for
	// this request (as represented by notifications/progress). The value of this
	// parameter is an opaque token that will be attached to any subsequent
	// notifications. The receiver is not obligated to provide these notifications.
	ProgressToken *ProgressToken `json:"progressToken,omitempty" yaml:"progressToken,omitempty" mapstructure:"progressToken,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// Parameters for a `resources/unsubscribe` request.
type UnsubscribeRequestParams struct {
	// See [General fields: `_meta`](/specification/2025-11-25/basic/index#meta) for
	// notes on `_meta` usage.
	Meta *UnsubscribeRequestParamsMeta `json:"_meta,omitempty" yaml:"_meta,omitempty" mapstructure:"_meta,omitempty"`

	// The URI of the resource. The URI can use any protocol; it is up to the server
	// how to interpret it.
	Uri string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnsubscribeRequestParams) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["uri"]; raw != nil && !ok {
		return fmt.Errorf("field uri in UnsubscribeRequestParams: required")
	}
	type Plain UnsubscribeRequestParams
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = UnsubscribeRequestParams(plain)
	return nil
}

// Sent from the client to request cancellation of resources/updated notifications
// from the server. This should follow a previous resources/subscribe request.
type UnsubscribeRequest struct {
	// Id corresponds to the JSON schema field "id".
	Id RequestId `json:"id" yaml:"id" mapstructure:"id"`

	// Jsonrpc corresponds to the JSON schema field "jsonrpc".
	Jsonrpc string `json:"jsonrpc" yaml:"jsonrpc" mapstructure:"jsonrpc"`

	// Method corresponds to the JSON schema field "method".
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	// Params corresponds to the JSON schema field "params".
	Params UnsubscribeRequestParams `json:"params" yaml:"params" mapstructure:"params"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnsubscribeRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in UnsubscribeRequest: required")
	}
	if _, ok := raw["jsonrpc"]; raw != nil && !ok {
		return fmt.Errorf("field jsonrpc in UnsubscribeRequest: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in UnsubscribeRequest: required")
	}
	if _, ok := raw["params"]; raw != nil && !ok {
		return fmt.Errorf("field params in UnsubscribeRequest: required")
	}
	type Plain UnsubscribeRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = UnsubscribeRequest(plain)
	return nil
}

// Schema for the array items.
type UntitledMultiSelectEnumSchemaItems struct {
	// Array of enum values to choose from.
	Enum []string `json:"enum" yaml:"enum" mapstructure:"enum"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UntitledMultiSelectEnumSchemaItems) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["enum"]; raw != nil && !ok {
		return fmt.Errorf("field enum in UntitledMultiSelectEnumSchemaItems: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in UntitledMultiSelectEnumSchemaItems: required")
	}
	type Plain UntitledMultiSelectEnumSchemaItems
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = UntitledMultiSelectEnumSchemaItems(plain)
	return nil
}

// Schema for multiple-selection enumeration without display titles for options.
type UntitledMultiSelectEnumSchema struct {
	// Optional default value.
	Default []string `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// Optional description for the enum field.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Schema for the array items.
	Items UntitledMultiSelectEnumSchemaItems `json:"items" yaml:"items" mapstructure:"items"`

	// Maximum number of items to select.
	MaxItems *int `json:"maxItems,omitempty" yaml:"maxItems,omitempty" mapstructure:"maxItems,omitempty"`

	// Minimum number of items to select.
	MinItems *int `json:"minItems,omitempty" yaml:"minItems,omitempty" mapstructure:"minItems,omitempty"`

	// Optional title for the enum field.
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UntitledMultiSelectEnumSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["items"]; raw != nil && !ok {
		return fmt.Errorf("field items in UntitledMultiSelectEnumSchema: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in UntitledMultiSelectEnumSchema: required")
	}
	type Plain UntitledMultiSelectEnumSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = UntitledMultiSelectEnumSchema(plain)
	return nil
}

// Schema for single-selection enumeration without display titles for options.
type UntitledSingleSelectEnumSchema struct {
	// Optional default value.
	Default *string `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// Optional description for the enum field.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Array of enum values to choose from.
	Enum []string `json:"enum" yaml:"enum" mapstructure:"enum"`

	// Optional title for the enum field.
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UntitledSingleSelectEnumSchema) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["enum"]; raw != nil && !ok {
		return fmt.Errorf("field enum in UntitledSingleSelectEnumSchema: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in UntitledSingleSelectEnumSchema: required")
	}
	type Plain UntitledSingleSelectEnumSchema
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = UntitledSingleSelectEnumSchema(plain)
	return nil
}
